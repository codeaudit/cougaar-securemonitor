#
# Declarations for type attributes.
# 

# A type attribute can be used to identify a set of types with a similar
# property.  Each type can have any number of attributes, and each
# attribute can be associated with any number of types.  Attributes are
# explicitly declared here, and can then be associated with particular
# types in type declarations.  Attribute names can then be used throughout 
# the configuration to express the set of types that are associated with 
# the attribute.  Except for the MLS attributes, attributes have no implicit
# meaning to SELinux.  The meaning of all other attributes are completely 
# defined through their usage within the configuration, but should be 
# documented here as comments preceding the attribute declaration.  

#####################
# Attributes for MLS:
#

# The mlstrustedreader attribute identifies every domain that can
# override the normal MLS restrictions on reading (i.e. domains
# that can read up).  
attribute mlstrustedreader;

# The mlstrustedwriter attribute identifies every domain that can
# override the normal MLS restrictions on writing (i.e. domains
# that can write down).  
attribute mlstrustedwriter;

# The mlstrustedobject attribute identifies every type that can
# be accessed without normal MLS restrictions (i.e. processes can
# read or write objects with this type regardless of MLS level).  
# Examples:  /dev/null, descriptors created by login
attribute mlstrustedobject;


#########################
# Attributes for domains:
#

# The domain attribute identifies every type that can be 
# assigned to a process.  This attribute is used in TE rules 
# that should be applied to all domains, e.g. permitting 
# init to kill all processes or permitting all processes
# to read a particular file.
attribute domain;

# The privuser attribute identifies every domain that can 
# change its SELinux user identity.  This attribute is used 
# in the constraints configuration.  NOTE:  This attribute
# is not required for domains that merely change the Linux
# uid attributes, only for domains that must change the
# SELinux user identity.
attribute privuser;

# The privrole attribute identifies every domain that can 
# change its SELinux role.  This attribute is used in the 
# constraints configuration.
attribute privrole;

# The privowner attribute identifies every domain that can 
# assign a different SELinux user identity to a file.  This 
# attribute is used in the constraints configuration.
attribute privowner;

# The privlog attribute identifies every domain that can 
# communicate with syslogd through its Unix domain socket.
# This attribute is used in the TE rules in 
# domains/program/syslogd.te to grant such access.  
# XXX If you want to mandate the use of this attribute for all 
# XXX domains that can log, then you should also write corresponding 
# XXX assertions in assert.te to enforce this restriction.  Otherwise,
# XXX it is just an optional convenience for domain writers.
attribute privlog;

# The privmem attribute identifies every domain that can 
# access kernel memory devices.
# This attribute is used in the TE assertions to verify
# that such access is limited to domains that are explicitly
# tagged with this attribute.
attribute privmem;

# The privfd attribute identifies every domain that should have
# file handles inherited widely (IE sshd_t and getty_t).
attribute privfd;

# The privhome attribute identifies every domain that can create files under
# regular user home directories in the regular context (IE act on behalf of
# a user in writing regular files)
attribute privhome;

# The auth attribute identifies every domain that needs
# to perform user authentication and requires access to
# the corresponding authentication data.  
# XXX This attribute is no longer in use except in type declarations.
# XXX It was introduced for the original attempt to put /etc/shadow into
# XXX a separate type and to limit read access to certain domains.  
# XXX Doing so transparently to applications is problematic due to
# XXX the fact that both /etc/passwd and /etc/shadow are recreated
# XXX by the same processes and live in the same directory, so file type
# XXX transition rules cannot specify different default types.  Relocating
# XXX /etc/shadow to a separate subdirectory was tried, but required
# XXX modifications to a lot of applications even after changing
# XXX the pwdb shared library.
attribute auth;

# The admin attribute identifies every administrator domain.
# It is used in TE assertions when verifying that only administrator 
# domains have certain permissions.  
# This attribute is presently associated with sysadm_t and 
# certain administrator utility domains.  
# XXX The use of this attribute should be reviewed for consistency.
# XXX Might want to partition into several finer-grained attributes 
# XXX used in different assertions within assert.te.
attribute admin;

# The userdomain attribute identifies every user domain, presently
# user_t and sysadm_t.  It is used in TE rules that should be applied
# to all user domains.
attribute userdomain;

# attribute for all non-administrative devpts types
attribute userpty_type;

# The user_crond_domain attribute identifies every user_crond domain, presently
# user_crond_t and sysadm_crond_t.  It is used in TE rules that should be
# applied to all user domains.
attribute user_crond_domain;

# The unpriv_userdomain identifies non-administrative users (default user_t)
attribute unpriv_userdomain;

# This attribute is for the main user home directory for unpriv users
attribute user_home_dir_type;

# The gphdomain attribute identifies every gnome-pty-helper derived
# domain.  It is used in TE rules to permit inheritance and use of
# descriptors created by these domains.
attribute gphdomain;


############################
# Attributes for file types:
#

# The file_type attribute identifies all types assigned to files 
# in persistent filesystems.  It is used in TE rules to permit
# the association of all such file types with persistent filesystem
# types, and to permit certain domains to access all such types as 
# appropriate.
attribute file_type;

# The sysadmfile attribute identifies all types assigned to files 
# that should be completely accessible to administrators.  It is used
# in TE rules to grant such access for administrator domains.
attribute sysadmfile;

# The fs_type attribute identifies all types assigned to filesystems
# (not limited to persistent filesystems).
# It is used in TE rules to permit certain domains to mount
# any filesystem and to permit most domains to obtain the
# overall filesystem statistics.
attribute fs_type;

# The root_dir_type attribute identifies all types assigned to 
# root directories of filesystems (not limited to persistent
# filesystems).
# XXX This attribute was used to grant mountassociate permission,
# XXX but this permission is no longer defined.  We can likely
# XXX remove this attribute.
attribute root_dir_type;

# The exec_type attribute identifies all types assigned
# to entrypoint executables for domains.  This attribute is 
# used in TE rules and assertions that should be applied to all 
# such executables.
attribute exec_type;

# The tmpfile attribute identifies all types assigned to temporary 
# files.  This attribute is used in TE rules to grant certain 
# domains the ability to remove all such files (e.g. init, crond).
attribute tmpfile;

# The user_tmpfile attribute identifies all types associated with temporary
# files for unpriv_userdomain domains.
attribute user_tmpfile;

# for the user_xserver_tmp_t etc
attribute xserver_tmpfile;

# The tmpfsfile attribute identifies all types defined for tmpfs 
# type transitions. 
# It is used in TE rules to grant certain domains the ability to
# access all such files.
attribute tmpfsfile;

# The home_type attribute identifies all types assigned to home
# directories.  This attribute is used in TE rules to grant certain
# domains the ability to access all home directory types.
attribute home_type;

# This attribute is for the main user home directory /home/user, to
# distinguish it from sub-dirs.  Often you want a process to be able to
# read the user home directory but not read the regular directories under it.
attribute home_dir_type;

# The ttyfile attribute identifies all types assigned to ttys.
# It is used in TE rules to grant certain domains the ability to
# access all ttys.
attribute ttyfile;

# The ptyfile attribute identifies all types assigned to ptys.
# It is used in TE rules to grant certain domains the ability to
# access all ptys.
attribute ptyfile;

# The pidfile attribute identifies all types assigned to pid files.
# It is used in TE rules to grant certain domains the ability to
# access all such files.
attribute pidfile;


############################
# Attributes for network types:
#

# The socket_type attribute identifies all types assigned to 
# kernel-created sockets.  Ordinary sockets are assigned the 
# domain of the creating process.
# XXX This attribute is unused.  Remove?
attribute socket_type;

# Identifies all types assigned to port numbers to control binding.
attribute port_type;

# Identifies all types assigned to network interfaces to control
# operations on the interface (XXX obsolete, not supported via LSM) 
# and to control traffic sent or received on the interface.
attribute netif_type;

# Identifies all default types assigned to packets received 
# on network interfaces.  
attribute netmsg_type;

# Identifies all types assigned to network nodes/hosts to control
# traffic sent to or received from the node.
attribute node_type;

# Identifier for log files or directories that only exist for log files.
attribute logfile;

# Identifier for lock files (/var/lock/*) or directories that only exist for
# lock files.
attribute lockfile;



##############################
# Attributes for security policy types:
#

# The login_contexts attribute idenitifies the files used
# to define default contexts for login types (e.g., login, cron).
attribute login_contexts;

# Identifier for a domain used by "sendmail -t" (IE user_mail_t,
# sysadm_mail_t, etc)
attribute user_mail_domain;

# Identifies domains that can transition to system_mail_t
attribute privmail;

# Type for non-sysadm home directory
attribute user_home_type;

# For domains that are part of a mail server and need to read user files and
# fifos, and inherit file handles to enable user email to get to the mail
# spool
attribute mta_user_agent;

# For domains that are part of a mail server for delivering messages to the
# user
attribute mta_delivery_agent;
define(`acme.te')
define(`checkpolicy.te')
define(`chkpwd.te')
define(`cougaar.te')
define(`crond.te')
define(`crontab.te')
define(`dhcpc.te')
define(`fsadm.te')
define(`getty.te')
define(`groupadd.te')
define(`ifconfig.te')
define(`initrc.te')
define(`init.te')
define(`klogd.te')
define(`ldconfig.te')
define(`load_policy.te')
define(`login.te')
define(`logrotate.te')
define(`modutil.te')
define(`mount.te')
define(`netutils.te')
define(`newrole.te')
define(`passwd.te')
define(`setfiles.te')
define(`seuser.te')
define(`snort.te')
define(`ssh.te')
define(`su.te')
define(`syslogd.te')
define(`tmpreaper.te')
define(`useradd.te')
define(`xauth.te')
define(`kernel.te')
#
# Macros for all admin domains.
#

#
# admin_domain(domain_prefix)
#
# Define derived types and rules for an administrator domain.
#
# The type declaration and role authorization for the domain must be
# provided separately.  Likewise, domain transitions into this domain
# must be specified separately.  If the every_domain() rules are desired,
# then these rules must also be specified separately.
#
undefine(`admin_domain')
define(`admin_domain',`
# Inherit rules for ordinary users.
user_domain($1)

# Violates the goal of limiting write access to checkpolicy.
#rw_dir_create_file($1_t, policy_config_t)

ifdef(`crond.te', `
allow $1_crond_t var_log_t:file r_file_perms;
')

# Allow system log read
allow $1_t kernel_t:system syslog_read;

# Use capabilities other than sys_module.
allow $1_t self:capability ~sys_module;

# Determine the set of legal user SIDs reachable from a given SID.
allow $1_t security_t:security { get_user_sids };

# Use system operations.
allow $1_t kernel_t:system *;

# Change system parameters.
can_sysctl($1_t)

# Create and use all files that have the sysadmfile attribute.
allow $1_t sysadmfile:notdevfile_class_set create_file_perms;
allow $1_t sysadmfile:dir create_dir_perms;

# Access removable devices.
allow $1_t removable_device_t:devfile_class_set rw_file_perms;

# Communicate with the init process.
allow $1_t initctl_t:fifo_file rw_file_perms;

# Examine all processes.
allow $1_t domain:dir r_dir_perms;
allow $1_t domain:notdevfile_class_set r_file_perms;

# Send signals to all processes.
allow $1_t { domain unlabeled_t }:process signal_perms;

# Access all user terminals.
allow $1_t tty_device_t:chr_file rw_file_perms;
allow $1_t ttyfile:chr_file rw_file_perms;
allow $1_t ptyfile:chr_file rw_file_perms;

# allow setting up tunnels
allow $1_t tun_tap_device_t:chr_file rw_file_perms;

# Run init (telinit).
can_exec($1_t, init_exec_t)

# Run programs from user home directories.
# Not ideal, but typical if users want to login as both sysadm_t or user_t.
can_exec($1_t, user_home_type)
# Run programs from /usr/src.
can_exec($1_t,src_t)

# Run admin programs that require different permissions in their own domain.
# These rules were moved into the appropriate program domain file.

# added by mayerf@tresys.com
# The following rules are temporary until such time that a complete
# policy management infrastructure is in place so that an administrator
# cannot directly manipulate policy files with arbitrary programs.
#
allow $1_t policy_src_t:notdevfile_class_set create_file_perms;
allow $1_t policy_src_t:dir create_dir_perms;

# Remove the binary policy.
allow $1_t policy_config_t:file unlink;

# Relabel all files.
allow $1_t file_type:dir { getattr read search relabelfrom relabelto };
allow $1_t file_type:file_class_set { getattr relabelfrom relabelto };

# Create files in /tmp/orbit-* and /tmp/.ICE-unix
# with our derived tmp type rather than user_tmp_t.
file_type_auto_trans($1_t, user_tmpfile, $1_tmp_t)

ifdef(`xserver.te',
`# Create files in /tmp/.X11-unix with our X servers derived
# tmp type rather than user_xserver_tmp_t.
file_type_auto_trans($1_xserver_t, xserver_tmpfile, $1_xserver_tmp_t)')

#
# A user who is authorized for sysadm_t may nonetheless have
# a home directory labeled with user_home_t if the user is expected
# to login in either user_t or sysadm_t.  Hence, the derived domains
# for programs need to be able to access user_home_t.  
# 

# Allow our xauth domain to write to .Xauthority.
ifdef(`xauth.te', `
file_type_auto_trans($1_xauth_t, user_home_dir_t, user_home_xauth_t)
')

# Allow our gph domain to write to .xsession-errors.
ifdef(`gnome-pty-helper.te', `
allow $1_gph_t user_home_dir_type:dir rw_dir_perms;
allow $1_gph_t user_home_type:file create_file_perms;
')

ifdef(`netscape.te',
`# Allow searching of /tmp/.X11-unix.
ifdef(`xserver.te', `allow $1_netscape_t user_xserver_tmp_t:dir r_dir_perms;')
# Allow our netscape domain to write to .netscape.
allow $1_netscape_t user_netscape_rw_t:dir create_dir_perms;
allow $1_netscape_t user_netscape_rw_t:{ file lnk_file } create_file_perms;
# Allow our domain to relabel downloaded files to its home type.
allow $1_t user_netscape_rw_t:{ dir file lnk_file } relabelfrom;')

ifdef(`gpg.te',
`# Allow our gpg domain to write to .gnupg
allow $1_gpg_t user_gpg_secret_t:dir create_dir_perms;
allow $1_gpg_t user_gpg_secret_t:file create_file_perms;')

# Allow our crontab domain to unlink a user cron spool file.
ifdef(`crontab.te',
`allow $1_crontab_t user_cron_spool_t:file unlink;')

#
# Allow sysadm to execute quota commands against filesystems and files.
#
allow $1_t fs_type:filesystem { quotamod quotaget };
allow $1_t file_t:file quotaon;

# Grant read and write access to /dev/console.
allow $1_t console_device_t:chr_file rw_file_perms;

# for lsof
allow $1_t domain:socket_class_set getattr;
')
##############################
#
# Global macros for the type enforcement (TE) configuration.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
# Modified: Howard Holm (NSA), <hdholm@epoch.ncsc.mil>
#           System V IPC added
#
#################################
# 
# Macros for groups of classes and 
# groups of permissions.
#

#
# All directory and file classes
#
define(`dir_file_class_set', `{ dir file lnk_file sock_file fifo_file chr_file blk_file }')

#
# All non-directory file classes.
#
define(`file_class_set', `{ file lnk_file sock_file fifo_file chr_file blk_file }')

#
# Non-device file classes.
#
define(`notdevfile_class_set', `{ file lnk_file sock_file fifo_file }')

#
# Device file classes.
#
define(`devfile_class_set', `{ chr_file blk_file }')

#
# All socket classes.
#
define(`socket_class_set', `{ tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket }')

#
# Datagram socket classes.
# 
define(`dgram_socket_class_set', `{ udp_socket unix_dgram_socket }')

#
# Stream socket classes.
#
define(`stream_socket_class_set', `{ tcp_socket unix_stream_socket }')

#
# Unprivileged socket classes (exclude rawip, netlink, packet).
#
define(`unpriv_socket_class_set', `{ tcp_socket udp_socket unix_stream_socket unix_dgram_socket }')


# 
# Permissions for getting file attributes.
#
define(`stat_file_perms', `{ getattr }')

# 
# Permissions for executing files.
#
define(`x_file_perms', `{ getattr execute }')

# 
# Permissions for reading files and their attributes.
#
define(`r_file_perms', `{ read getattr lock ioctl }')

# 
# Permissions for reading and executing files.
#
define(`rx_file_perms', `{ read getattr lock execute ioctl }')

# 
# Permissions for reading and writing files and their attributes.
#
define(`rw_file_perms', `{ ioctl read getattr lock write append }')

# 
# Permissions for reading and appending to files.
#
define(`ra_file_perms', `{ ioctl read getattr lock append }')

#
# Permissions for linking, unlinking and renaming files.
# 
define(`link_file_perms', `{ getattr link unlink rename }')

#
# Permissions for creating and using files.
# 
define(`create_file_perms', `{ create ioctl read getattr lock write setattr append link unlink rename }')

# 
# Permissions for reading directories and their attributes.
#
define(`r_dir_perms', `{ read getattr lock search ioctl }')

# 
# Permissions for reading and writing directories and their attributes.
#
define(`rw_dir_perms', `{ read getattr lock search ioctl add_name remove_name write }')

# 
# Permissions for reading and adding names to directories.
#
define(`ra_dir_perms', `{ read getattr lock search ioctl add_name write }')


#
# Permissions for creating and using directories.
# 
define(`create_dir_perms', `{ create read getattr lock setattr link unlink rename search add_name remove_name reparent write rmdir }')

#
# Permissions to mount and unmount file systems.
#
define(`mount_fs_perms', `{ mount remount unmount getattr }')

#
# Permissions for using sockets.
# 
define(`rw_socket_perms', `{ ioctl read getattr write setattr append bind connect getopt setopt shutdown }')

#
# Permissions for creating and using sockets.
# 
define(`create_socket_perms', `{ create ioctl read getattr write setattr append bind connect getopt setopt shutdown }')

#
# Permissions for using stream sockets.
# 
define(`rw_stream_socket_perms', `{ ioctl read getattr write setattr append bind connect getopt setopt shutdown listen accept }')

#
# Permissions for creating and using stream sockets.
# 
define(`create_stream_socket_perms', `{ create ioctl read getattr write setattr append bind connect getopt setopt shutdown listen accept }')


#
# Permissions for sending all signals.
#
define(`signal_perms', `{ sigchld sigkill sigstop signull signal }')

#
# Permissions for sending and receiving network packets.
#
define(`packet_perms', `{ tcp_recv tcp_send udp_recv udp_send rawip_recv rawip_send }')

#
# Permissions for using System V IPC
#
define(`r_sem_perms', `{ associate getattr read unix_read }')
define(`rw_sem_perms', `{ associate getattr setattr create destroy read write unix_read unix_write }')
define(`r_msgq_perms', `{ associate getattr read unix_read }')
define(`rw_msgq_perms', `{ associate getattr setattr create destroy read write enqueue unix_read unix_write }')
define(`r_shm_perms', `{ associate getattr read unix_read }')
define(`rw_shm_perms', `{ associate getattr setattr create destroy read write lock unix_read unix_write }')

#################################
# 
# Macros for type transition rules and
# access vector rules.
#

#
# Simple combinations for reading and writing both
# directories and files.
# 
define(`r_dir_file', `
allow $1 $2:dir r_dir_perms;
allow $1 $2:{ file lnk_file } r_file_perms;
')

define(`rw_dir_file', `
allow $1 $2:dir rw_dir_perms;
allow $1 $2:{ file lnk_file } rw_file_perms;
')

define(`ra_dir_file', `
allow $1 $2:dir ra_dir_perms;
allow $1 $2:{ file lnk_file } ra_file_perms;
')

define(`rw_dir_create_file', `
allow $1 $2:dir rw_dir_perms;
allow $1 $2:{ file lnk_file } create_file_perms;
')

define(`create_dir_file', `
allow $1 $2:dir create_dir_perms;
allow $1 $2:{ file lnk_file } create_file_perms;
')

define(`create_dir_notdevfile', `
allow $1 $2:dir create_dir_perms;
allow $1 $2:notdevfile_class_set create_file_perms;
')

define(`create_append_log_file', `
allow $1 $2:dir { read getattr search add_name write };
allow $1 $2:file { create ioctl getattr setattr append link };
')

#################################
#
# domain_trans(parent_domain, program_type, child_domain)
#
# Permissions for transitioning to a new domain.
#

define(`domain_trans',`

#
# Allow the process to transition to the new domain.
#
allow $1 $3:process transition;

#
# Allow the process to execute the program.
# 
allow $1 $2:file x_file_perms;

#
# Allow the process to reap the new domain.
#
allow $3 $1:process sigchld;

#
# Allow the new domain to inherit and use file 
# descriptions from the creating process and vice versa.
#
allow $3 $1:fd use;
allow $1 $3:fd use;

#
# Allow the new domain to write back to the old domain via a pipe.
#
allow $3 $1:fifo_file rw_file_perms;

#
# Allow the new domain to read and execute the program.
#
allow $3 $2:file rx_file_perms;

#
# Allow the new domain to be entered via the program.
#
allow $3 $2:file entrypoint;
')

#################################
#
# domain_auto_trans(parent_domain, program_type, child_domain)
#
# Define a default domain transition and allow it.
#
define(`domain_auto_trans',`
domain_trans($1,$2,$3)
type_transition $1 $2:process $3;
')

define(`domain_auto_trans_read',`
domain_auto_trans($1, $2, $3)
allow $1 $2:file read;
')

#################################
#
# uses_shlib(domain)
#
# Permissions for using shared libraries.
#
define(`uses_shlib',`
allow $1 { root_t usr_t lib_t etc_t }:dir r_dir_perms;
allow $1 ld_so_t:file rx_file_perms;
allow $1 ld_so_t:file execute_no_trans;
allow $1 ld_so_t:lnk_file r_file_perms;
allow $1 shlib_t:file rx_file_perms;
allow $1 shlib_t:lnk_file r_file_perms;
allow $1 ld_so_cache_t:file r_file_perms;
allow $1 null_device_t:chr_file rw_file_perms;
')

define(`uses_java', `
allow $1 any_socket_t:udp_socket { sendto };
allow $1 port_t:udp_socket { ioctl recvfrom name_bind };
allow $1 netif_eth0_t:netif { udp_recv };
allow $1 node_t:node { tcp_recv };
allow $1 resolv_conf_t:file { read };
allow $1 tcp_socket_t:tcp_socket { recvfrom };
allow $1 var_yp_t:file { setattr write };
')

#################################
#
# can_ptrace(domain, domain)
#
# Permissions for running ptrace (strace or gdb) on another domain
#
define(`can_ptrace',`
allow $1 $2:process ptrace;
')

#################################
#
# can_exec(domain, type)
#
# Permissions for executing programs with
# a specified type without changing domains.
#
define(`can_exec',`
allow $1 $2:file { rx_file_perms execute_no_trans };
')

#################################
#
# can_exec_any(domain)
#
# Permissions for executing a variety
# of executable types.
#
define(`can_exec_any',`
allow $1 { bin_t sbin_t lib_t etc_t }:dir r_dir_perms;
allow $1 { bin_t sbin_t }:lnk_file read;
uses_shlib($1)
can_exec($1, etc_t)
can_exec($1, lib_t)
can_exec($1, bin_t)
can_exec($1, sbin_t)
can_exec($1, exec_type)
')


#################################
#
# file_type_trans(domain, dir_type, file_type)
#
# Permissions for transitioning to a new file type.
#

define(`file_type_trans',`

#
# Allow the process to modify the directory.
#
allow $1 $2:dir rw_dir_perms;

#
# Allow the process to create the file.
#
ifelse(`$4', `', `
allow $1 $3:notdevfile_class_set create_file_perms;
allow $1 $3:dir create_dir_perms;
', `
allow $1 $3:$4 create_file_perms;
')

')

#################################
#
# file_type_auto_trans(creator_domain, parent_directory_type, file_type, object_class)
#
# the object class will default to notdevfile_class_set if not specified as
# the fourth parameter
#
# Define a default file type transition and allow it.
#
define(`file_type_auto_trans',`
ifelse(`$4', `', `
file_type_trans($1,$2,$3)
type_transition $1 $2:dir $3;
type_transition $1 $2:notdevfile_class_set $3;
', `
file_type_trans($1,$2,$3,$4)
type_transition $1 $2:$4 $3;
')

')

#################################
#
# can_network(domain)
#
# Permissions for accessing the network.
# See types/network.te for the network types.
# See net_contexts for security contexts for network entities.
#
define(`can_network',`
#
# Allow the domain to create and use UDP and TCP sockets.
# Other kinds of sockets must be separately authorized for use.
allow $1 self:udp_socket create_socket_perms;
allow $1 self:tcp_socket create_stream_socket_perms;

#
# Allow the domain to send UDP packets.
# Since the destination sockets type is unknown, the generic
# any_socket_t type is used as a placeholder.
#
allow $1 any_socket_t:udp_socket sendto;

#
# Allow the domain to send using any network interface.
# netif_type is a type attribute for all network interface types.
#
allow $1 netif_type:netif { tcp_send udp_send rawip_send };

#
# Allow packets sent by the domain to be received on any network interface.
#
allow $1 netif_type:netif { tcp_recv udp_recv rawip_recv };

#
# Allow the domain to receive packets from any network interface.
# netmsg_type is a type attribute for all default message types.
#
allow $1 netmsg_type:{ udp_socket tcp_socket rawip_socket } recvfrom;

#
# Allow the domain to initiate or accept TCP connections 
# on any network interface.
#
allow $1 netmsg_type:tcp_socket { connectto acceptfrom };

#
# Receive resets from the TCP reset socket.
# The TCP reset socket is labeled with the tcp_socket_t type.
#
allow $1 tcp_socket_t:tcp_socket recvfrom;

dontaudit $1 tcp_socket_t:tcp_socket connectto;

#
# Allow the domain to send to any node.
# node_type is a type attribute for all node types.
#
allow $1 node_type:node { tcp_send udp_send rawip_send };

#
# Allow packets sent by the domain to be received from any node.
#
allow $1 node_type:node { tcp_recv udp_recv rawip_recv };

#
# Allow the domain to send NFS client requests via the socket
# created by mount.
#
allow $1 mount_t:udp_socket rw_socket_perms;

#
# Bind to the default port type.
# Other port types must be separately authorized.
#
allow $1 port_t:udp_socket name_bind;
allow $1 port_t:tcp_socket name_bind;
')

#################################
#
# can_unix_connect(client, server)
#
# Permissions for establishing a Unix stream connection.
#
define(`can_unix_connect',`
allow $1 $2:unix_stream_socket connectto;
')

#################################
#
# can_unix_send(sender, receiver)
#
# Permissions for sending Unix datagrams.
#
define(`can_unix_send',`
allow $1 $2:unix_dgram_socket sendto;
')

#################################
#
# can_tcp_connect(client, server)
#
# Permissions for establishing a TCP connection.
#
define(`can_tcp_connect',`
allow $1 $2:tcp_socket { connectto recvfrom };
allow $2 $1:tcp_socket { acceptfrom recvfrom };
allow $2 tcp_socket_t:tcp_socket { recvfrom };
allow $1 tcp_socket_t:tcp_socket { recvfrom };
')

#################################
#
# can_udp_send(sender, receiver)
#
# Permissions for sending/receiving UDP datagrams.
#
define(`can_udp_send',`
allow $1 $2:udp_socket { sendto };
allow $2 $1:udp_socket { recvfrom };
')

#################################
#
# can_sysctl(domain)
#
# Permissions for modifying sysctl parameters.
#
define(`can_sysctl',`
allow $1 sysctl_t:dir r_dir_perms;
allow $1 sysctl_t:file { setattr rw_file_perms };
allow $1 sysctl_fs_t:dir r_dir_perms;
allow $1 sysctl_fs_t:file { setattr rw_file_perms };
allow $1 sysctl_kernel_t:dir r_dir_perms;
allow $1 sysctl_kernel_t:file { setattr rw_file_perms };
allow $1 sysctl_net_t:dir r_dir_perms;
allow $1 sysctl_net_t:file { setattr rw_file_perms };
allow $1 sysctl_net_unix_t:dir r_dir_perms;
allow $1 sysctl_net_unix_t:file { setattr rw_file_perms };
allow $1 sysctl_vm_t:dir r_dir_perms;
allow $1 sysctl_vm_t:file { setattr rw_file_perms };
allow $1 sysctl_dev_t:dir r_dir_perms;
allow $1 sysctl_dev_t:file { setattr rw_file_perms };
allow $1 sysctl_modprobe_t:file { setattr rw_file_perms };
')


##################################
#
# can_create_pty(domain_prefix, attributes)
#
# Permissions for creating ptys.
#
define(`can_create_pty',`

type $1_devpts_t, file_type, sysadmfile, ptyfile $2;

# Allow the pty to be associated with the file system.
allow $1_devpts_t devpts_t:filesystem associate;

# Access the pty master multiplexer.
allow $1_t ptmx_t:chr_file rw_file_perms;

# Label pty files with a derived type.
type_transition $1_t devpts_t:chr_file $1_devpts_t;

# Read and write my pty files.
allow $1_t $1_devpts_t:chr_file { setattr rw_file_perms };

ifdef(`devfsd.te', `
allow $1_t device_t:filesystem getattr;
')

')


##################################
#
# can_create_other_pty(domain_prefix,other_domain)
#
# Permissions for creating ptys for another domain.
#
define(`can_create_other_pty',`

# Access the pty master multiplexer.
allow $1_t ptmx_t:chr_file rw_file_perms;

# Label pty files with a derived type.
type_transition $1_t devpts_t:chr_file $2_devpts_t;

# Read and write pty files.
allow $1_t $2_devpts_t:chr_file { setattr rw_file_perms };

ifdef(`devfsd.te', `
allow $1_t device_t:filesystem getattr;
')

')



################################################
#
# The following macros are an attempt to start
# partitioning every_domain into finer-grained subsets
# that can be used by individual domains.
#

#
# general_domain_access(domain)
#
# Grant permissions within the domain.
# This includes permissions to processes, /proc/PID files,
# file descriptors, pipes, Unix sockets, and System V IPC objects
# labeled with the domain.
#
define(`general_domain_access',`
# Access other processes in the same domain.
allow $1 self:process *;

# Access /proc/PID files for processes in the same domain.
allow $1 self:dir r_dir_perms;
allow $1 self:notdevfile_class_set r_file_perms;

# Access file descriptions, pipes, and sockets
# created by processes in the same domain.
allow $1 self:fd *;
allow $1 self:fifo_file rw_file_perms;
allow $1 self:unix_dgram_socket create_socket_perms;
allow $1 self:unix_stream_socket create_stream_socket_perms;

# Allow the domain to communicate with other processes in the same domain.
allow $1 self:unix_dgram_socket sendto;
allow $1 self:unix_stream_socket connectto;

# Access System V IPC objects created by processes in the same domain.
allow $1 self:sem  rw_sem_perms;
allow $1 self:msg  { send receive };
allow $1 self:msgq rw_msgq_perms;
allow $1 self:shm  rw_shm_perms;

')

#
# general_proc_read_access(domain)
#
# Grant read/search permissions to most of /proc, excluding
# the /proc/PID directories and the /proc/kmsg and /proc/kcore files.
# The general_domain_access macro grants access to the domain /proc/PID
# directories, but not to other domains.  Only permissions to stat
# are granted for /proc/kmsg and /proc/kcore, since these files are more
# sensitive.
# 
define(`general_proc_read_access',`
# Read system information files in /proc.
allow $1 proc_t:dir r_dir_perms;
allow $1 proc_t:notdevfile_class_set r_file_perms;

# Stat /proc/kmsg and /proc/kcore.
allow $1 proc_kmsg_t:file stat_file_perms;
allow $1 proc_kcore_t:file stat_file_perms;

# Read system variables in /proc/sys.
allow $1 sysctl_modprobe_t:file r_file_perms;
allow $1 sysctl_t:file r_file_perms;
allow $1 sysctl_t:dir r_dir_perms;
allow $1 sysctl_fs_t:file r_file_perms;
allow $1 sysctl_fs_t:dir r_dir_perms;
allow $1 sysctl_kernel_t:file r_file_perms;
allow $1 sysctl_kernel_t:dir r_dir_perms;
allow $1 sysctl_net_t:file r_file_perms;
allow $1 sysctl_net_t:dir r_dir_perms;
allow $1 sysctl_vm_t:file r_file_perms;
allow $1 sysctl_vm_t:dir r_dir_perms;
allow $1 sysctl_dev_t:file r_file_perms;
allow $1 sysctl_dev_t:dir r_dir_perms;
')

#
# base_file_read_access(domain)
#
# Grant read/search permissions to a few system file types.
#
define(`base_file_read_access',`
# Read /.
allow $1 root_t:dir r_dir_perms;
allow $1 root_t:notdevfile_class_set r_file_perms;

# Read /home.
allow $1 home_root_t:dir r_dir_perms;

# Read /usr.
allow $1 usr_t:dir r_dir_perms;
allow $1 usr_t:notdevfile_class_set r_file_perms;

# Read bin and sbin directories.
allow $1 bin_t:dir r_dir_perms;
allow $1 bin_t:notdevfile_class_set r_file_perms;
allow $1 sbin_t:dir r_dir_perms;
allow $1 sbin_t:notdevfile_class_set r_file_perms;
')

#
# general_file_read_access(domain)
#
# Grant read/search permissions to many system file types.
#
define(`general_file_read_access',`
errprint(`m4: '__file__:__line__: `Warning:  general_file_read_access is deprecated.
')
# Get attributes of file systems.
allow $1 fs_type:filesystem getattr;

base_file_read_access($1)

# Read directories and files with the readable_t type.
# This type is a general type for "world"-readable files.
allow $1 readable_t:dir r_dir_perms;
allow $1 readable_t:notdevfile_class_set r_file_perms;

# Stat /...security and lost+found.
allow $1 file_labels_t:dir getattr;
allow $1 lost_found_t:dir getattr;

# Read the devpts root directory.  
allow $1 devpts_t:dir r_dir_perms;
ifdef(`sshd.te',
`allow $1 sshd_devpts_t:dir r_dir_perms;')

# Read the /tmp directory and any /tmp files with the base type.
# Temporary files created at runtime will typically use derived types.
allow $1 tmp_t:dir r_dir_perms;
allow $1 tmp_t:{ file lnk_file } r_file_perms;

# Read /var.
allow $1 var_t:dir r_dir_perms;
allow $1 var_t:notdevfile_class_set r_file_perms;

# Read /var/catman.
allow $1 catman_t:dir r_dir_perms;
allow $1 catman_t:{ file lnk_file } r_file_perms;

# Read /var/lib.
allow $1 var_lib_t:dir r_dir_perms;
allow $1 var_lib_t:notdevfile_class_set r_file_perms;
allow $1 var_lib_nfs_t:dir r_dir_perms;
allow $1 var_lib_nfs_t:notdevfile_class_set r_file_perms;
ifdef(`rpm.te',
`allow $1 var_lib_rpm_t:dir r_dir_perms;
allow $1 var_lib_rpm_t:{ file lnk_file} r_file_perms;')
r_dir_file($1, tetex_data_t)

# Read /var/yp.
allow $1 var_yp_t:dir r_dir_perms;
allow $1 var_yp_t:notdevfile_class_set r_file_perms;

# Read /var/spool.
allow $1 var_spool_t:dir r_dir_perms;
allow $1 var_spool_t:notdevfile_class_set r_file_perms;

# Read /var/run, /var/lock, /var/log.
allow $1 var_run_t:dir r_dir_perms;
allow $1 var_run_t:{ file lnk_file } r_file_perms;
allow $1 var_log_t:dir r_dir_perms;
#allow $1 var_log_t:{ file lnk_file } r_file_perms;
allow $1 var_log_sa_t:dir r_dir_perms;
allow $1 var_log_sa_t:{ file lnk_file } r_file_perms;
allow $1 var_log_ksyms_t:{ file lnk_file } r_file_perms;
ifdef(`rpm.te', `allow $1 var_log_rpm_t:{ file lnk_file } r_file_perms;')
allow $1 var_lock_t:dir r_dir_perms;
allow $1 var_lock_t:{ file lnk_file } r_file_perms;

# Read /var/run/utmp and /var/log/wtmp.
allow $1 initrc_var_run_t:file r_file_perms;
allow $1 wtmp_t:file r_file_perms;

# Read /boot, /boot/System.map*, and /vmlinuz*
allow $1 boot_t:dir { search getattr };
allow $1 boot_t:file getattr;
allow $1 system_map_t:{ file lnk_file } r_file_perms;
ifdef(`rpm.te', `
allow $1 boot_runtime_t:{ file lnk_file } r_file_perms;
')
allow $1 boot_t:lnk_file read;

# Read /etc.
allow $1 etc_t:dir r_dir_perms;
allow $1 etc_t:notdevfile_class_set r_file_perms;
allow $1 etc_runtime_t:{ file lnk_file } r_file_perms;
allow $1 etc_aliases_t:{ file lnk_file } r_file_perms;
allow $1 etc_mail_t:dir r_dir_perms;
allow $1 etc_mail_t:{ file lnk_file } r_file_perms;
allow $1 resolv_conf_t:{ file lnk_file } r_file_perms;
allow $1 ld_so_cache_t:file r_file_perms;

# Read /lib.
allow $1 lib_t:dir r_dir_perms;
allow $1 lib_t:notdevfile_class_set r_file_perms;

# Read the linker, shared library, and executable types.
allow $1 ld_so_t:{ file lnk_file } r_file_perms;
allow $1 shlib_t:{ file lnk_file } r_file_perms;
allow $1 exec_type:{ file lnk_file } r_file_perms;

# Read man directories and files.
allow $1 man_t:dir r_dir_perms;
allow $1 man_t:notdevfile_class_set r_file_perms;

# Read /usr/src.
allow $1 src_t:dir r_dir_perms;
allow $1 src_t:notdevfile_class_set r_file_perms;

# Read module-related files.
allow $1 modules_object_t:dir r_dir_perms;
allow $1 modules_object_t:{ file lnk_file } r_file_perms;
allow $1 modules_dep_t:{ file lnk_file } r_file_perms;
allow $1 modules_conf_t:{ file lnk_file} r_file_perms;

# Read /dev directories and any symbolic links.
allow $1 device_t:dir r_dir_perms;
allow $1 device_t:lnk_file r_file_perms;

# Read /dev/random and /dev/zero.
allow $1 random_device_t:chr_file r_file_perms;
allow $1 zero_device_t:chr_file r_file_perms;

# Read the root directory of a tmpfs filesytem and any symbolic links.
allow $1 tmpfs_t:dir r_dir_perms;
allow $1 tmpfs_t:lnk_file r_file_perms;

# Read any symbolic links on a devfs file system.
allow $1 device_t:lnk_file r_file_perms;

# Read the root directory of a usbdevfs filesystem, and
# the devices and drivers files.  Permit stating of the
# device nodes, but nothing else.
allow $1 usbdevfs_t:dir r_dir_perms;
allow $1 usbdevfs_t:{ file lnk_file } r_file_perms;
allow $1 usbdevfs_device_t:file getattr;
')

#
# general_file_write_access(domain)
#
# Grant write permissions to a small set of system file types, e.g. 
# /dev/tty, /dev/null, etc.
#
# For shared directories like /tmp, each domain should have its own derived
# type (with a file_type_auto_trans rule) for files created in the shared
# directory.
#
define(`general_file_write_access',`
errprint(`m4: '__file__:__line__: `Warning:  general_file_write_access is deprecated.
')
# Read and write /dev/tty and /dev/null.
allow $1 devtty_t:chr_file rw_file_perms;
allow $1 { null_device_t zero_device_t }:chr_file rw_file_perms;

# Do not audit write denials to /etc/ld.so.cache.
dontaudit $1 ld_so_cache_t:file write;
')

#
# every_test_domain(domain)
#
# Grant permissions common to the test domains.
#
define(`every_test_domain',`
# Grant permissions within the domain.
general_domain_access($1)

# Grant read/search permissions to most of /proc.
general_proc_read_access($1)

# Grant read/search permissions to many system file types.
general_file_read_access($1)

# Grant write permissions to a small set of system file types.
# No permission to create files is granted here.  Use allow rules to grant 
# create permissions to a type or use file_type_auto_trans rules to set up
# new types for files.
general_file_write_access($1)

# Execute from the system shared libraries.
# No permission to execute anything else is granted here.
# Use can_exec or can_exec_any to grant the ability to execute within a domain.
# Use domain_auto_trans for executing and changing domains.
uses_shlib($1)

# read localization information
allow $1 locale_t:dir r_dir_perms;
allow $1 locale_t:{file lnk_file} r_file_perms;

# Obtain the context of any SID, the SID for any context, 
# and the list of active SIDs.
allow $1 security_t:security { sid_to_context context_to_sid get_sids };

')

################################
#
# every_domain(domain)
#
# Grant permissions common to most domains.
#
# This macro replaces the rules formerly located in domains/every.te.
# An every_domain macro has been inserted into each domain .te file
# for each domain defined within that file.  If you want a new domain
# to inherit these rules, then you can likewise use this macro in
# your new domain .te file.  However, for least privilege purposes, you 
# may want to consider using macros or individual rules that only include 
# a subset of these permissions for your new domain.  This macro has already 
# been partitioned into a few subsets, with corresponding macros defined 
# above and used in defining this macro.  
#
define(`every_domain',`
errprint(`m4: '__file__:__line__: `Warning:  every_domain is deprecated.
')
# Grant the permissions common to the test domains.
every_test_domain($1)

# Grant permissions needed to create TCP and UDP sockets and 
# to access the network.
can_network($1)
')

#######################
# daemon_base_domain(domain_prefix, attribs)
#
# Define a daemon domain with a base set of type declarations
# and permissions that are common to most daemons.
# attribs is the list of attributes which must start with `,' if it is not empty
#
# Author:  Russell Coker <russell@coker.com.au>
#
define(`daemon_base_domain', `
type $1_t, domain, privlog $2;
type $1_exec_t, file_type, sysadmfile, exec_type;

role system_r types $1_t;

domain_auto_trans(initrc_t, $1_exec_t, $1_t)

# Inherit and use descriptors from init.
allow $1_t init_t:fd use;
allow $1_t init_t:process sigchld;
allow $1_t privfd:fd use;
ifdef(`newrole.te', `allow $1_t newrole_t:process sigchld;')
allow $1_t self:process { signal_perms fork };

uses_shlib($1_t)

allow $1_t { self proc_t }:dir r_dir_perms;
allow $1_t { self proc_t }:lnk_file read;

allow $1_t device_t:dir { getattr search };
allow $1_t null_device_t:chr_file rw_file_perms;
allow $1_t console_device_t:chr_file rw_file_perms;
allow $1_t initrc_devpts_t:chr_file rw_file_perms;
')dnl

define(`daemon_domain', `
daemon_base_domain($1, `$2')
# Create pid file.
allow $1_t var_t:dir { getattr search };
type var_run_$1_t, file_type, sysadmfile, pidfile;
file_type_auto_trans($1_t, var_run_t, var_run_$1_t)

allow $1_t devtty_t:chr_file rw_file_perms;

# for daemons that look at /root on startup
dontaudit $1_t sysadm_home_dir_t:dir search;

# for df
allow $1_t fs_type:filesystem getattr;
')dnl

define(`uses_authbind',
`domain_auto_trans_read($1, authbind_exec_t, authbind_t)
allow authbind_t $1:process sigchld;
allow authbind_t $1:fd use;
allow authbind_t $1:{ tcp_socket udp_socket } rw_socket_perms;
')

# define a sub-domain, $1_t is the parent domain, $2 is the name
# of the sub-domain.
#
define(`daemon_sub_domain', `
# $1 is the parent domain (or domains), $2_t is the child domain,
# and $3 is any attributes to apply to the child
type $2_t, domain, privlog $3;
type $2_exec_t, file_type, sysadmfile, exec_type;

role system_r types $2_t;

domain_auto_trans($1, $2_exec_t, $2_t)

# Inherit and use descriptors from parent.
allow $2_t $1:fd use;
allow $2_t $1:process sigchld;

allow $2_t self:process signal_perms;

uses_shlib($2_t)

allow $2_t { self proc_t }:dir r_dir_perms;
allow $2_t { self proc_t }:lnk_file read;

allow $2_t device_t:dir { getattr search };
allow $2_t null_device_t:chr_file rw_file_perms;
')


define(`tmp_domain', `
type $1_tmp_t, file_type, sysadmfile, tmpfile $2;
file_type_auto_trans($1_t, tmp_t, $1_tmp_t)
')

define(`var_lib_domain', `
type var_lib_$1_t, file_type, sysadmfile;
file_type_auto_trans($1_t, var_lib_t, var_lib_$1_t)
')

define(`log_domain', `
type $1_log_t, file_type, sysadmfile, logfile;
file_type_auto_trans($1_t, var_log_t, $1_log_t)
')

define(`lock_domain', `
type $1_lock_t, file_type, sysadmfile, lockfile;
file_type_auto_trans($1_t, var_lock_t, $1_lock_t)
')

#######################
# application_domain(domain_prefix)
#
# Define a domain with a base set of type declarations
# and permissions that are common to simple applications.
#
# Author:  Russell Coker <russell@coker.com.au>
#
define(`application_domain', `
type $1_t, domain, privlog;
type $1_exec_t, file_type, sysadmfile, exec_type;
role sysadm_r types $1_t;
domain_auto_trans(sysadm_t, $1_exec_t, $1_t)
uses_shlib($1_t)
')

define(`user_application_domain', `
application_domain($1)
in_user_role($1_t)
domain_auto_trans(userdomain, $1_exec_t, $1_t)
')

define(`system_domain', `
type $1_t, domain, privlog $2;
type $1_exec_t, file_type, sysadmfile, exec_type;
role system_r types $1_t;
uses_shlib($1_t)
allow $1_t etc_t:dir r_dir_perms;
')


#
# Macros for all user login domains.
#

#
# user_domain(domain_prefix)
#
# Define derived types and rules for an ordinary user domain.
#
# The type declaration and role authorization for the domain must be
# provided separately.  Likewise, domain transitions into this domain
# must be specified separately.  
#
undefine(`user_domain')
define(`user_domain',`
# Use capabilities
allow $1_t self:capability { setgid chown fowner };
dontaudit $1_t self:capability { sys_nice fsetid };

# Type for home directory.
ifelse($1, sysadm, `
type $1_home_dir_t, file_type, sysadmfile, home_dir_type, home_type;
type $1_home_t, file_type, sysadmfile, home_type;
tmp_domain($1)
', `
type $1_home_dir_t, file_type, sysadmfile, home_dir_type, user_home_dir_type, home_type, user_home_type;
type $1_home_t, file_type, sysadmfile, home_type, user_home_type;
# do not allow privhome access to sysadm_home_dir_t
file_type_auto_trans(privhome, $1_home_dir_t, $1_home_t)
tmp_domain($1, `, user_tmpfile')
')

# Create, access, and remove files in home directory.
file_type_auto_trans($1_t, $1_home_dir_t, $1_home_t)
allow $1_t $1_home_t:dir_file_class_set { relabelfrom relabelto };

# Bind to a Unix domain socket in /tmp.
allow $1_t $1_tmp_t:unix_stream_socket name_bind;

# Type for tty devices.
type $1_tty_device_t, file_type, sysadmfile, ttyfile;
# Access ttys.
allow $1_t $1_tty_device_t:chr_file { setattr rw_file_perms };
# Use the type when relabeling terminal devices.
type_change $1_t tty_device_t:chr_file $1_tty_device_t;
ifdef(`dpkg.te', `
# Debian login is from shadow utils and does not allow resetting the perms.
# have to fix this!
type_change $1_t ttyfile:chr_file $1_tty_device_t;
')

# Type and access for pty devices.
ifelse(`$1', `sysadm', `
can_create_pty($1)
', `
can_create_pty($1, `, userpty_type')
')

# Use the type when relabeling pty devices.
ifdef(`rlogind.te',
`type_change $1_t rlogind_devpts_t:chr_file $1_devpts_t;')
ifdef(`ssh.te', `
type_change $1_t sshd_devpts_t:chr_file $1_devpts_t;

# Connect to sshd.
can_tcp_connect($1_t, sshd_t)

# Connect to ssh proxy.
can_tcp_connect($1_t, $1_ssh_t)

allow $1_t sshd_t:fd use;
allow $1_t sshd_t:tcp_socket rw_stream_socket_perms;
# Use a Unix stream socket inherited from sshd.
allow $1_t sshd_t:unix_stream_socket rw_stream_socket_perms;
')dnl end of ssh section

# Type for tmpfs/shm files.
type $1_tmpfs_t, file_type, sysadmfile, tmpfsfile;
# Use the type when creating files in tmpfs.
file_type_auto_trans($1_t, tmpfs_t, $1_tmpfs_t)
allow $1_tmpfs_t tmpfs_t:filesystem associate;

# Read and write /var/catman.
allow $1_t catman_t:dir rw_dir_perms;
allow $1_t catman_t:notdevfile_class_set create_file_perms;

# Modify mail spool file.
allow $1_t mail_spool_t:dir r_dir_perms;
allow $1_t mail_spool_t:file rw_file_perms;
allow $1_t mail_spool_t:lnk_file read;

#
# Allow the query of filesystem quotas
#
allow $1_t fs_type:filesystem quotaget;

# Run helper programs.
can_exec_any($1_t)
# Run programs developed by other users in the same domain.
can_exec($1_t, $1_home_t)
can_exec($1_t, $1_tmp_t)

# Run user programs that require different permissions in their own domain.
# These rules were moved into the individual program domains.

# Instantiate derived domains for a number of programs.
# These derived domains encode both information about the calling
# user domain and the program, and allow us to maintain separation
# between different instances of the program being run by different
# user domains.
ifdef(`gnome-pty-helper.te', `gph_domain($1)')
ifdef(`su.te', `su_domain($1)')
ifdef(`chkpwd.te', `chkpwd_domain($1)')
ifdef(`screen.te', `screen_domain($1)')
ifdef(`netscape.te', `netscape_domain($1)')
ifdef(`games.te', `
x_client_domain($1, games)
rw_dir_create_file($1_games_t, games_data_t)
')
ifdef(`gpg.te', `gpg_domain($1)')
ifdef(`xauth.te', `xauth_domain($1)')
ifdef(`xserver.te', `xserver_domain($1)')
ifdef(`lpr.te', `lpr_domain($1)')
ifdef(`mta.te', `mail_domain($1)')
ifdef(`sendmail.te', `sendmail_user_domain($1)')
ifdef(`crontab.te', `crontab_domain($1)')
ifdef(`ssh.te', `ssh_domain($1)')
ifdef(`irc.te', `irc_domain($1)')
ifdef(`clamav.te', `user_clamscan_domain($1)')
ifdef(`fingerd.te', `fingerd_macro($1)')

# Instantiate a derived domain for user cron jobs.
ifdef(`crond.te', `crond_domain($1)')

ifdef(`vmware.te', `
# probably should have a separate domain for each user
file_type_auto_trans(vmware_user_t, $1_home_dir_t, vmware_user_file_t)
')

# Read the mouse.
allow $1_t mouse_device_t:chr_file r_file_perms;
# Access other miscellaneous devices.
allow $1_t misc_device_t:file_class_set rw_file_perms;

# Use the network.
can_network($1_t)

#
# connect_secure and sendmsg_secure calls with a 
# peer or destination socket SID can be enforced
# when using the loopback interface.  Enforcement
# for real network interfaces will be possible when
# a packet labeling mechanism is integrated.
#
allow $1_t node_lo_t:node enforce_dest;

# Communicate within the domain.
can_udp_send($1_t, $1_t)
can_tcp_connect($1_t, $1_t)

# Connect to inetd.
ifdef(`inetd.te', `can_tcp_connect($1_t,inetd_t)')

ifdef(`rshd.te',
`# Connect second port to rshd.
can_tcp_connect(rshd_t, $1_t)')

# Connect data port to ftpd.
ifdef(`ftpd.te', `can_tcp_connect(ftpd_t, $1_t)')

# Connect to portmap.
ifdef(`portmap.te', `can_tcp_connect($1_t, portmap_t)')

# Inherit and use sockets from inetd
ifdef(`inetd.te',
`allow $1_t inetd_t:fd use;
allow $1_t inetd_t:tcp_socket rw_stream_socket_perms;')

# Allow system log read
#allow $1_t kernel_t:system syslog_read;
# else do not log it
dontaudit $1_t kernel_t:system syslog_read;

# Very permissive allowing every domain to see every type.
allow $1_t kernel_t:system { ipc_info };

# When the user domain runs ps, there will be a number of access
# denials when ps tries to search /proc.  Do not audit these denials.
dontaudit $1_t domain:dir r_dir_perms;
dontaudit $1_t domain:notdevfile_class_set r_file_perms;

# Some shells ask for w access to utmp, but will operate
# correctly without it.  Do not audit write denials to utmp.
dontaudit $1_t initrc_var_run_t:file { getattr read write };

# do not audit getattr on tmpfile, otherwise ls -l /tmp fills the logs
dontaudit $1_t tmpfile:dir_file_class_set getattr;

# do not audit getattr on disk devices, otherwise KDE fills the logs
dontaudit $1_t { removable_device_t fixed_disk_device_t }:blk_file getattr;

ifdef(`xdm.te', `
# Connect to the X server run by the X Display Manager.
can_unix_connect($1_t, xdm_t)
allow $1_t xdm_tmp_t:sock_file rw_file_perms;
allow $1_t xdm_tmp_t:dir r_dir_perms;
allow $1_t xdm_xserver_tmp_t:sock_file { read write };
allow $1_t xdm_xserver_tmp_t:dir search;

ifelse(`$1', sysadm, `', `
file_type_auto_trans(xdm_t, $1_home_dir_t, $1_home_xauth_t, file)
')dnl end ifelse sysadm
')dnl end ifdef xdm.te

# Access the sound device.
allow $1_t sound_device_t:chr_file { getattr read write ioctl };

# Allow reading dpkg origins file
ifdef(`dpkg.te', `
r_dir_file($1_t, etc_dpkg_t)
')

ifdef(`ftpd.te', `
# uncomment the following for FTP access to all home directories
# or you can just enable FTP access for certain user domains in the ftpd.te
# file
#file_type_auto_trans(ftpd_t, $1_home_dir_t, $1_home_t)
')

')


###########################################################################
#
# Domains for ordinary users.
#
undefine(`full_user_role')
define(`full_user_role', `

# user_t/$1_t is an unprivileged users domain.
type $1_t, domain, userdomain, unpriv_userdomain;

# $1_r is authorized for $1_t for the initial login domain.
role $1_r types $1_t;
allow system_r $1_r;

# Grant permissions within the domain.
general_domain_access($1_t);

# Grant read/search permissions to some of /proc.
allow $1_t proc_t:dir r_dir_perms;
allow $1_t proc_t:{ file lnk_file } r_file_perms;

# Grand read/search permissions to many system types.
#general_file_read_access($1_t);
# Get attributes of file systems.
allow $1_t fs_type:filesystem getattr;

base_file_read_access($1_t)

# Read directories and files with the readable_t type.
# This type is a general type for "world"-readable files.
allow $1_t readable_t:dir r_dir_perms;
allow $1_t readable_t:notdevfile_class_set r_file_perms;

# Stat /...security and lost+found.
allow $1_t file_labels_t:dir getattr;
allow $1_t lost_found_t:dir getattr;

# Read the devpts root directory.
allow $1_t devpts_t:dir r_dir_perms;
ifdef(`sshd.te',
`allow $1_t sshd_devpts_t:dir r_dir_perms;')

# Read the /tmp directory and any /tmp files with the base type.
# Temporary files created at runtime will typically use derived types.
allow $1_t tmp_t:dir r_dir_perms;
allow $1_t tmp_t:{ file lnk_file } r_file_perms;

# Read /var, /var/spool, /var/run.
allow $1_t var_t:dir r_dir_perms;
allow $1_t var_t:notdevfile_class_set r_file_perms;
allow $1_t var_spool_t:dir r_dir_perms;
allow $1_t var_spool_t:notdevfile_class_set r_file_perms;
allow $1_t var_run_t:dir r_dir_perms;
allow $1_t var_run_t:{ file lnk_file } r_file_perms;

# Read /etc.
allow $1_t etc_t:dir r_dir_perms;
allow $1_t etc_t:notdevfile_class_set r_file_perms;
allow $1_t etc_runtime_t:{ file lnk_file } r_file_perms;

# Read man directories and files.
allow $1_t man_t:dir r_dir_perms;
allow $1_t man_t:notdevfile_class_set r_file_perms;

# Read /dev directories and any symbolic links.
allow $1_t device_t:dir r_dir_perms;
allow $1_t device_t:lnk_file r_file_perms;

# Read and write /dev/tty and /dev/null.
allow $1_t devtty_t:chr_file rw_file_perms;
allow $1_t { null_device_t zero_device_t }:chr_file rw_file_perms;

# Do not audit write denials to /etc/ld.so.cache.
dontaudit $1_t ld_so_cache_t:file write;

# Execute from the system shared libraries.
uses_shlib($1_t);

# Obtain the context of any SID, the SID for any context,
# and the list of active SIDs.
allow $1_t security_t:security { sid_to_context context_to_sid get_sids };

# $1_t is also granted permissions specific to user domains.
user_domain($1)

# When an ordinary user domain runs su, su may try to
# update the /root/.Xauthority file, and the user shell may
# try to update the shell history. This isnt allowed, but 
# we dont need to audit it.
ifdef(`su.te', `
dontaudit $1_su_t sysadm_home_t:dir  { read getattr search write add_name remove_name };
dontaudit $1_su_t sysadm_home_t:file { read getattr create write link unlink };')
dontaudit $1_t    sysadm_home_t:dir { read search getattr };
dontaudit $1_t    sysadm_home_t:file { read getattr append };

ifdef(`syslogd.te', `
# Some programs that are left in $1_t will try to connect
# to syslogd, but we do not want to let them generate log messages.
# Do not audit.
dontaudit $1_t devlog_t:sock_file { read write };
dontaudit $1_t syslogd_t:unix_dgram_socket sendto;
')

# stop warnings about "ls -l" on directories with unlabelled files
dontaudit $1_t file_t:{ dir file lnk_file } getattr;
')

undefine(`in_user_role')
define(`in_user_role', `
role user_r types $1;
role cougaar_r types $1;
#role staff_r types $1;
')


#
# Macros for chkpwd domains.
#

#
# chkpwd_domain(domain_prefix)
#
# Define a derived domain for the *_chkpwd program when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/su.te. 
#
undefine(`chkpwd_domain')
ifdef(`chkpwd.te', `
define(`chkpwd_domain',`
# Derived domain based on the calling user domain and the program.
type $1_chkpwd_t, domain, privlog, auth;

# Transition from the user domain to this domain.
domain_auto_trans($1_t, chkpwd_exec_t, $1_chkpwd_t)

# The user role is authorized for this domain.
role $1_r types $1_chkpwd_t;

# This domain is granted permissions common to most domains (includes can_net)
every_domain($1_chkpwd_t)

# Use capabilities.
allow $1_chkpwd_t self:capability setuid;

# Inherit and use descriptors from gnome-pty-helper.
ifdef(`gnome-pty-helper.te',`allow $1_chkpwd_t $1_gph_t:fd use;')

# Inherit and use descriptors from newrole.
ifdef(`newrole.te', `allow $1_chkpwd_t newrole_t:fd use;')

# Write to the user domain tty.
allow $1_chkpwd_t $1_tty_device_t:chr_file rw_file_perms;
allow $1_chkpwd_t $1_devpts_t:chr_file rw_file_perms;
')

', `

define(`chkpwd_domain',`')

')

# macro for chroot environments
# Author Russell Coker

# chroot(initial_domain, basename, role, tty_device_type)
define(`chroot', `

ifelse(`$1', `initrc', `
define(`chroot_role', `system_r')
define(`chroot_tty_device', `{ console_device_t admin_tty_type }')
define(`chroot_mount_domain', `mount_t')
define(`chroot_fd_use', `{ privfd init_t }')
', `
define(`chroot_role', `$1_r')
define(`chroot_tty_device', `{ $1_devpts_t $1_tty_device_t }')
define(`chroot_fd_use', `privfd')

# allow mounting /proc and /dev
ifdef(`$1_mount_def', `', `
mount_domain($1, $1_mount)
role chroot_role types $1_mount_t;
')
define(`chroot_mount_domain', `$1_mount_t')
ifdef(`ssh.te', `
can_tcp_connect($1_ssh_t, $2_t)
')dnl end ssh
')dnl end ifelse initrc

# types for read-only and read-write files in the chroot
type $2_ro_t, file_type, sysadmfile, home_type, user_home_type;
type $2_rw_t, file_type, sysadmfile, home_type, user_home_type;
# type like $2_ro_t but that triggers a transition from $2_super_t to $2_t
# when you execute it
type $2_dropdown_t, file_type, sysadmfile, home_type, user_home_type;

allow chroot_mount_domain { $2_rw_t $2_ro_t }:dir { getattr search mounton };
allow chroot_mount_domain { $2_rw_t $2_ro_t }:file { getattr mounton };

# entry point for $2_super_t
type $2_super_entry_t, file_type, sysadmfile, home_type, user_home_type;
# $2_t is the base domain, has full access to $2_rw_t files
type $2_t, domain, userdomain, unpriv_userdomain;
# $2_super_t is the super-chroot domain, can also write to $2_ro_t
# but still can not access outside the chroot
type $2_super_t, domain, userdomain, unpriv_userdomain;
allow $2_super_t chroot_tty_device:chr_file rw_file_perms;

ifdef(`$1_chroot_def', `', `
dnl can not have this defined twice
define(`$1_chroot_def')

allow chroot_mount_domain { proc_t device_t fs_t }:filesystem { mount unmount };

# $1_chroot_t is the domain for /usr/sbin/chroot
type $1_chroot_t, domain;

# allow $1_chroot_t to write to the tty device
allow $1_chroot_t chroot_tty_device:chr_file rw_file_perms;
allow $1_chroot_t chroot_fd_use:fd use;
allow { $1_chroot_t $2_t $2_super_t } $1_t:fd use;

role chroot_role types $1_chroot_t;
uses_shlib($1_chroot_t)
allow $1_chroot_t self:capability sys_chroot;
allow $1_t $1_chroot_t:dir { search getattr read };
allow $1_t $1_chroot_t:{ file lnk_file } { read getattr };
domain_auto_trans($1_t, chroot_exec_t, $1_chroot_t)
allow $1_chroot_t fs_t:filesystem getattr;
')dnl End conditional

role chroot_role types { $2_t $2_super_t };

# allow ps to show processes and allow killing them
allow $1_t { $2_super_t $2_t }:dir { search getattr read };
allow $1_t { $2_super_t $2_t }:{ file lnk_file } { read getattr };
allow $1_t { $2_super_t $2_t }:process signal_perms;
allow $2_super_t $2_t:dir { search getattr read };
allow $2_super_t $2_t:{ file lnk_file } { read getattr };
allow { $1_t $2_super_t } $2_t:process { signal_perms ptrace };
allow $1_t $2_super_t:process { signal_perms ptrace };
allow sysadm_t { $2_super_t $2_t }:process { signal_perms ptrace };

allow { $2_super_t $2_t } { fs_t device_t }:filesystem getattr;
allow { $2_super_t $2_t } device_t:dir { search getattr };
allow { $2_super_t $2_t } devtty_t:chr_file rw_file_perms;
allow { $2_super_t $2_t } random_device_t:chr_file r_file_perms;
allow { $2_super_t $2_t } self:capability { fowner chown fsetid setgid setuid net_bind_service sys_tty_config };
allow $2_super_t self:capability sys_ptrace;

can_tcp_connect($2_super_t, $2_t)
allow { $2_super_t $2_t } $2_rw_t:sock_file create_file_perms;

allow { $2_super_t $2_t } devpts_t:dir { getattr search read };

# quiet ps and killall
dontaudit { $2_super_t $2_t } domain:dir { search getattr };

# allow $2_t to write to the owner tty device (should remove this)
allow $2_t chroot_tty_device:chr_file { read write };

r_dir_file($1_chroot_t, { $2_ro_t $2_rw_t $2_super_entry_t $2_dropdown_t })
can_exec($2_t, { $2_ro_t $2_rw_t $2_super_entry_t $2_dropdown_t })
can_exec($2_super_t, { $2_ro_t $2_super_entry_t })
create_dir_notdevfile($2_super_t, { $2_ro_t $2_rw_t $2_super_entry_t $2_dropdown_t })
# $2_super_t transitions to $2_t when it executes
# any file that $2_t can write
domain_auto_trans($2_super_t, { $2_rw_t $2_dropdown_t }, $2_t)
allow $1_chroot_t { $2_ro_t $2_rw_t }:lnk_file read;
r_dir_file($2_t, { $2_ro_t $2_super_entry_t $2_dropdown_t })
create_dir_notdevfile($2_t, $2_rw_t)
allow $2_t $2_rw_t:fifo_file create_file_perms;
allow $2_t $2_ro_t:fifo_file rw_file_perms;
allow { $1_t $2_super_t } { $2_rw_t $2_ro_t }:fifo_file create_file_perms;
create_dir_notdevfile($1_t, { $2_ro_t $2_rw_t $2_super_entry_t $2_dropdown_t })
can_exec($1_t, { $2_ro_t $2_dropdown_t })
domain_auto_trans($1_chroot_t, { $2_ro_t $2_rw_t $2_dropdown_t }, $2_t)
domain_auto_trans_read($1_chroot_t, $2_super_entry_t, $2_super_t)
allow { $1_t $2_super_t } { $2_ro_t $2_rw_t $2_super_entry_t $2_dropdown_t }:{ dir notdevfile_class_set } { relabelfrom relabelto };
general_proc_read_access({ $2_t $2_super_t })
general_domain_access({ $2_t $2_super_t })
can_create_pty($2)
can_create_pty($2_super)
can_network({ $2_t $2_super_t })
allow { $2_t $2_super_t } null_device_t:chr_file rw_file_perms;
allow $2_super_t { $2_rw_t $2_ro_t }:{ dir file } mounton;
allow { $2_t $2_super_t } self:capability { dac_override kill };

undefine(`chroot_role')
undefine(`chroot_tty_device')
undefine(`chroot_mount_domain')
undefine(`chroot_fd_use')
')
#
# Macros for clamscan
#
# Author:  Brian May <bam@snoopy.apana.org.au>
#

#
# clamscan_domain(domain_prefix)
#
# Define a derived domain for the clamscan program when executed
#
define(`clamscan_domain', `
# Derived domain based on the calling user domain and the program.
type $1_clamscan_t, domain, privlog;
# Transition from the user domain to the derived domain.
domain_auto_trans($1_t, clamscan_exec_t, $1_clamscan_t)
# Uses shared librarys
uses_shlib($1_clamscan_t)

# Access virus signatures
allow $1_clamscan_t var_lib_t:dir search;
# /etc/alternatives/oav-virussignatures and /etc/localtime
allow $1_clamscan_t etc_t:lnk_file read;
# /var/lib/oav-update and /var/lib/oav-virussignatures
allow $1_clamscan_t oav_update_var_lib_t:lnk_file read;
allow $1_clamscan_t oav_update_var_lib_t:dir r_dir_perms;
allow $1_clamscan_t oav_update_var_lib_t:file r_file_perms;

# Why is this required?
allow $1_clamscan_t proc_t:dir r_dir_perms;
allow $1_clamscan_t proc_t:file r_file_perms;
allow $1_clamscan_t sysctl_kernel_t:dir r_dir_perms;
allow $1_clamscan_t sysctl_kernel_t:file r_file_perms;
allow $1_clamscan_t self:unix_stream_socket { connect create read write };
')

define(`user_clamscan_domain',`
clamscan_domain($1)
allow $1_clamscan_t $1_tty_device_t:chr_file rw_file_perms;
allow $1_clamscan_t $1_devpts_t:chr_file rw_file_perms;
allow $1_clamscan_t $1_home_t:dir r_dir_perms;
allow $1_clamscan_t $1_home_t:file r_file_perms;
ifdef(`gnome-pty-helper.te', `allow $1_clamscan_t $1_gph_t:fd use;')
')
#
# Macros for crond domains.
#

#
# Authors:  Jonathan Crowley (MITRE) <jonathan@mitre.org>,
#	    Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser
#

#
# crond_domain(domain_prefix)
#
# Define a derived domain for cron jobs executed by crond on behalf 
# of a user domain.  These domains are separate from the top-level domain
# defined for the crond daemon and the domain defined for system cron jobs,
# which are specified in domains/program/crond.te.
#
undefine(`crond_domain')
define(`crond_domain',`
# Derived domain for user cron jobs, user user_crond_domain if not system
ifelse(`system', `$1', `
type $1_crond_t, domain;
', `
type $1_crond_t, domain, user_crond_domain;
')

# Permit a transition from the crond_t domain to this domain.
# The transition is requested explicitly by the modified crond 
# via execve_secure.  There is no way to set up an automatic
# transition, since crontabs are configuration files, not executables.
domain_trans(crond_t, shell_exec_t, $1_crond_t)

ifdef(`mta.te', `
domain_auto_trans($1_crond_t, sendmail_exec_t, $1_mail_t)
# $1_mail_t should only be reading from the cron fifo not needing to write
dontaudit $1_mail_t crond_t:fifo_file write;
allow mta_user_agent $1_crond_t:fd use;
')

# The user role is authorized for this domain.
role $1_r types $1_crond_t;

# This domain is granted permissions common to most domains.
every_domain($1_crond_t)

# Use capabilities.
allow $1_crond_t $1_crond_t:capability dac_override;

# Inherit and use descriptors from initrc.
allow $1_crond_t initrc_t:fd use;

# 
# Since crontab files are not directly executed,
# crond must ensure that the crontab file has
# a type that is appropriate for the domain of
# the user cron job.  It performs an entrypoint
# permission check for this purpose.
#
allow $1_crond_t $1_cron_spool_t:file entrypoint;

# Access user files and dirs.
file_type_auto_trans($1_crond_t, $1_home_dir_t, $1_home_t)

file_type_auto_trans($1_crond_t, tmp_t, $1_tmp_t)

# Run helper programs.
can_exec_any($1_crond_t)

# Run scripts in user home directory.
can_exec($1_crond_t, $1_home_t)
')

# When system_crond_t domain executes a type $1 executable then transition to
# domain $2, allow $2 to interact with crond_t as well.
define(`system_crond_entry', `
domain_auto_trans(system_crond_t, $1, $2)
allow $2 crond_t:fifo_file { getattr read write ioctl };
# a rule for privfd may make this obsolete
allow $2 crond_t:fd use;
allow $2 crond_t:process sigchld;
')
#
# Macros for crontab domains.
#

#
# Authors:  Jonathan Crowley (MITRE) <jonathan@mitre.org>
# Revised by Stephen Smalley <sds@epoch.ncsc.mil>
#

#
# crontab_domain(domain_prefix)
#
# Define a derived domain for the crontab program when executed by
# a user domain.  
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/crontab.te. 
#
undefine(`crontab_domain')
define(`crontab_domain',`
# Derived domain based on the calling user domain and the program.
type $1_crontab_t, domain, privlog;

# Transition from the user domain to the derived domain.
domain_auto_trans($1_t, crontab_exec_t, $1_crontab_t)

# The user role is authorized for this domain.
role $1_r types $1_crontab_t;

# This domain is granted permissions common to most domains (including can_net)
every_domain($1_crontab_t)

# Use capabilities
allow $1_crontab_t $1_crontab_t:capability { setuid setgid chown };

# Type for temporary files.
file_type_auto_trans($1_crontab_t, tmp_t, $1_tmp_t)

# Type of user crontabs once moved to cron spool.
type $1_cron_spool_t, file_type, sysadmfile;
# Use the type when creating files in /var/spool/cron.
allow sysadm_crontab_t $1_cron_spool_t:file { getattr read };
file_type_auto_trans($1_crontab_t, cron_spool_t, $1_cron_spool_t)
ifdef(`fcron.te', `
allow crond_t $1_cron_spool_t:file create_file_perms;
# fcron wants an instant update of a crontab change for the administrator
ifelse(`$1', `sysadm', `
allow $1_crontab_t crond_t:process signal;
', `
dontaudit $1_crontab_t crond_t:process signal;
')dnl end ifelse
')dnl end ifdef fcron

# crontab signals crond by updating the mtime on the spooldir
allow $1_crontab_t cron_spool_t:dir setattr;
# Allow crond to read those crontabs in cron spool.
allow crond_t $1_cron_spool_t:file r_file_perms;

# Run helper programs as $1_t
domain_auto_trans($1_crontab_t, { bin_t sbin_t exec_type }, $1_t)

# Read user crontabs 
allow $1_crontab_t { $1_home_t $1_home_dir_t }:dir r_dir_perms;  
allow $1_crontab_t $1_home_t:file r_file_perms;  
dontaudit $1_crontab_t $1_home_dir_t:dir write;

# Access the cron log file.
allow $1_crontab_t cron_log_t:file r_file_perms;
allow $1_crontab_t cron_log_t:file { append };

# Access terminals.
allow $1_crontab_t $1_tty_device_t:chr_file rw_file_perms;
allow $1_crontab_t $1_devpts_t:chr_file rw_file_perms;

# Inherit and use descriptors from gnome-pty-helper.
ifdef(`gnome-pty-helper.te', `allow $1_crontab_t $1_gph_t:fd use;')

')
#
# Macro for fingerd
#
# Author:  Russell Coker <russell@coker.com.au>
#

#
# fingerd_macro(domain_prefix)
#
# allow fingerd to create a fingerlog file in the user home dir
#
define(`fingerd_macro', `
type $1_home_fingerlog_t, file_type, sysadmfile;
file_type_auto_trans(fingerd_t, $1_home_dir_t, $1_home_fingerlog_t)
')
#
# Macros for gpg and pgp
#
# Author:  Russell Coker <russell@coker.com.au>
#
# based on the work of:
# Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser
#

#
# gpg_domain(domain_prefix)
#
# Define a derived domain for the gpg/pgp program when executed by
# a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/gpg.te.
#
define(`gpg_domain', `
# Derived domain based on the calling user domain and the program.
type $1_gpg_t, domain, privlog;
# Transition from the user domain to the derived domain.
domain_auto_trans($1_t, gpg_exec_t, $1_gpg_t)

can_network($1_gpg_t)

# for a bug in kmail
dontaudit $1_gpg_t $1_t:unix_stream_socket { read write };

# The user role is authorized for this domain.
role $1_r types $1_gpg_t;

type $1_gpg_secret_t, file_type, sysadmfile;

allow $1_t $1_gpg_secret_t:file getattr;

allow $1_gpg_t device_t:dir r_dir_perms;
allow $1_gpg_t random_device_t:chr_file r_file_perms;

allow $1_gpg_t { etc_t resolv_conf_t }:file r_file_perms;

allow $1_gpg_t self:unix_stream_socket create_stream_socket_perms;
allow $1_gpg_t self:tcp_socket create_stream_socket_perms;

allow $1_gpg_t { $1_devpts_t $1_tty_device_t }:chr_file rw_file_perms;
ifdef(`gnome-pty-helper.te', `allow $1_gpg_t $1_gph_t:fd use;')
allow $1_gpg_t privfd:fd use;

# Inherit and use descriptors
allow $1_gpg_t $1_t:fd use;
allow $1_gpg_t $1_t:process sigchld;
allow { $1_t $1_gpg_t } $1_gpg_t:process signal;

# allow ps to show gpg
allow $1_t $1_gpg_t:dir { search getattr read };
allow $1_t $1_gpg_t:{ file lnk_file } { read getattr };

uses_shlib($1_gpg_t)

# should not need read access...
allow $1_gpg_t home_root_t:dir { read search };

# use $1_gpg_secret_t for files it creates
# NB we are doing the type transition for directory creation only!
# so ~/.gnupg will be of $1_gpg_secret_t, then files created under it such as
# secring.gpg will be of $1_gpg_secret_t too.  But when you use gpg to decrypt
# a file and write output to your home directory it will use user_home_t.
file_type_auto_trans($1_gpg_t, $1_home_dir_t, $1_gpg_secret_t, dir)
rw_dir_create_file($1_gpg_t, $1_gpg_secret_t)

file_type_auto_trans($1_gpg_t, $1_home_dir_t, $1_home_t, file)
create_dir_file($1_gpg_t, $1_home_t)

# allow the usual access to /tmp
file_type_auto_trans($1_gpg_t, tmp_t, $1_tmp_t)

allow $1_gpg_t self:capability { ipc_lock setuid };
allow $1_gpg_t devtty_t:chr_file rw_file_perms;

allow $1_gpg_t { etc_t usr_t }:dir r_dir_perms;
allow $1_gpg_t fs_t:filesystem getattr;
allow $1_gpg_t usr_t:file r_file_perms;
allow $1_gpg_t etc_t:lnk_file r_file_perms;
allow $1_t $1_gpg_secret_t:dir rw_dir_perms;
')
#
# Macros for gnome-pty-helper domains.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser 
#

#
# gph_domain(domain_prefix)
#
# Define a derived domain for the gnome-pty-helper program when
# executed by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/gnome-pty-helper.te. 
#
# The *_gph_t domains are for the gnome_pty_helper program.
# This program is executed by gnome-terminal to handle
# updates to utmp and wtmp.  In this regard, it is similar
# to utempter.  However, unlike utempter, gnome-pty-helper
# also creates the pty file for the terminal program.
# There is one *_gph_t domain for each user domain.  
#
undefine(`gph_domain')
define(`gph_domain',`
# Derived domain based on the calling user domain and the program.
type $1_gph_t, domain, gphdomain;

# Transition from the user domain to the derived domain.
domain_auto_trans($1_t, gph_exec_t, $1_gph_t)

# The user role is authorized for this domain.
role $1_r types $1_gph_t;

# This domain is granted permissions common to most domains.
every_domain($1_gph_t)

# Use capabilities.
allow $1_gph_t $1_gph_t:capability { setuid setgid fsetid };

# Create ptys for the user domain.
can_create_other_pty($1_gph, $1)

# Update /var/run/utmp and /var/log/wtmp.
allow $1_gph_t initrc_var_run_t:file rw_file_perms;
allow $1_gph_t wtmp_t:file rw_file_perms;

# Allow gph to rw to stream sockets of appropriate user type.
# (Need this so gnome-pty-helper can pass pty fd to parent 
#  gnome-terminal which is running in a user domain.)
allow $1_gph_t $1_t:unix_stream_socket rw_stream_socket_perms;

# Read and write the users tty.
allow $1_gph_t $1_tty_device_t:chr_file rw_file_perms;

# Allow user domain to use pty fd from gnome-pty-helper.
allow $1_t $1_gph_t:fd use;

# Use the network, e.g. for NIS lookups.
can_network($1_gph_t)

# Added by David A. Wheeler:
# Allow gnome-pty-helper to update /var/log/lastlog
# (the gnome-pty-helper in Red Hat Linux 7.1 does this):
allow $1_gph_t lastlog_t:file rw_file_perms;

# Allow gnome-pty-helper to write the .xsession-errors file.
allow $1_gph_t home_root_t:dir search;
allow $1_gph_t $1_home_t:dir { search add_name };
allow $1_gph_t $1_home_t:file { create write };
')

#
# Macros for irc domains.
#

#
# Author:  Russell Coker <russell@coker.com.au>
#

#
# irc_domain(domain_prefix)
#
# Define a derived domain for the irc program when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/irc.te. 
#
undefine(`irc_domain')
ifdef(`irc.te', `
define(`irc_domain',`
# Derived domain based on the calling user domain and the program.
type $1_irc_t, domain;
type $1_home_irc_t, file_type, sysadmfile;
type $1_irc_exec_t, file_type, sysadmfile;

allow $1_t { $1_home_irc_t $1_irc_exec_t }:file { relabelfrom relabelto create_file_perms };

ifdef(`ircd.te', `
can_tcp_connect($1_irc_t, ircd_t)
')

# Transition from the user domain to this domain.
domain_auto_trans($1_t, { irc_exec_t $1_irc_exec_t }, $1_irc_t)

# The user role is authorized for this domain.
role $1_r types $1_irc_t;

# Inherit and use descriptors from gnome-pty-helper.
ifdef(`gnome-pty-helper.te',
`allow $1_irc_t $1_gph_t:fd use;
allow $1_t $1_gph_t:fd use;')

# Inherit and use descriptors from newrole.
ifdef(`newrole.te', `allow $1_irc_t newrole_t:fd use;')

# allow ps to show irc
allow $1_t $1_irc_t:dir { search getattr read };
allow $1_t $1_irc_t:{ file lnk_file } { read getattr };
allow $1_t $1_irc_t:process signal;

# Use the network.
can_network($1_irc_t)

uses_shlib($1_irc_t)
allow $1_irc_t { etc_t resolv_conf_t }:file { read getattr };
allow $1_irc_t etc_t:lnk_file read;
allow $1_irc_t fs_t:filesystem getattr;
allow $1_irc_t var_t:dir search;
allow $1_irc_t devpts_t:dir { getattr read search };
allow $1_irc_t device_t:dir search;
allow $1_irc_t devtty_t:chr_file rw_file_perms;
allow $1_irc_t self:unix_stream_socket create_stream_socket_perms;
allow $1_irc_t privfd:fd use;
allow $1_irc_t proc_t:dir search;
allow $1_irc_t { self proc_t }:lnk_file read;
allow $1_irc_t self:dir search;
dontaudit $1_irc_t var_run_t:dir search;

# Write to the user domain tty.
allow $1_irc_t $1_tty_device_t:chr_file rw_file_perms;
allow $1_irc_t $1_devpts_t:chr_file rw_file_perms;

# allow utmp access
allow $1_irc_t initrc_var_run_t:file read;
dontaudit $1_irc_t initrc_var_run_t:file lock;

# access config files
allow $1_irc_t home_root_t:dir search;
file_type_auto_trans($1_irc_t, $1_home_dir_t, $1_home_irc_t, file)

# access files under /tmp
file_type_auto_trans($1_irc_t, tmp_t, $1_tmp_t)
')

', `

define(`irc_domain',`')

')
#
# Macros for lpr domains.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser 
#

#
# lpr_domain(domain_prefix)
#
# Define a derived domain for the lpr/lpq/lprm programs when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/lpr.te. 
#
undefine(`lpr_domain')
define(`lpr_domain',`
# Derived domain based on the calling user domain and the program
type $1_lpr_t, domain, privlog;

# Transition from the user domain to the derived domain.
domain_auto_trans($1_t, lpr_exec_t, $1_lpr_t)

# The user role is authorized for this domain.
role $1_r types $1_lpr_t;

# This domain is granted permissions common to most domains (including can_net)
every_domain($1_lpr_t)

# Use capabilities.
allow $1_lpr_t $1_lpr_t:capability { setuid dac_override net_bind_service chown };

# Type for temporary files.
type $1_lpr_tmp_t, file_type, sysadmfile, tmpfile;
# Use this type when creating files in /tmp. 
file_type_auto_trans($1_lpr_t, tmp_t, $1_lpr_tmp_t)
r_dir_file($1_lpr_t, $1_tmp_t)

# Type for spool files.
type $1_print_spool_t, file_type, sysadmfile;
# Use this type when creating files in /var/spool/lpd and /var/spool/cups.
file_type_auto_trans($1_lpr_t, print_spool_t, $1_print_spool_t)

# Access the terminal.
allow $1_lpr_t $1_tty_device_t:chr_file rw_file_perms;
allow $1_lpr_t $1_devpts_t:chr_file rw_file_perms;

# Inherit and use descriptors from gnome-pty-helper.
ifdef(`gnome-pty-helper.te', `allow $1_lpr_t $1_gph_t:fd use;')

# Read user files. 
allow $1_lpr_t { $1_home_t $1_home_dir_t }:dir search;  
allow $1_lpr_t $1_home_t:{ file lnk_file } r_file_perms;  

# Read and write shared files in the spool directory.
allow $1_lpr_t print_spool_t:notdevfile_class_set rw_file_perms;

# lpr can run in lightweight mode, without a local print spooler. If the
# lpd policy is present, grant some permissions for this domain and the lpd
# domain to interact.
ifdef(`lpd.te', `
allow $1_lpr_t lpd_var_run_t:dir search;
allow $1_lpr_t lpd_var_run_t:sock_file write;

# Allow lpd to read, rename, and unlink spool files.
allow lpd_t $1_print_spool_t:file r_file_perms;
allow lpd_t $1_print_spool_t:file link_file_perms;

# Connect to lpd via a Unix domain socket.
allow $1_lpr_t printer_t:sock_file rw_file_perms;
can_unix_connect($1_lpr_t, lpd_t)
dontaudit $1_lpr_t $1_t:unix_stream_socket { read write };

# Connect to lpd via a TCP socket.
can_tcp_connect($1_lpr_t, lpd_t)

# Send SIGHUP to lpd.
allow $1_lpr_t lpd_t:process signal;

')

ifdef(`cups.te', `
allow { $1_lpr_t $1_t } etc_cupsd_t:dir search;
can_tcp_connect({ $1_lpr_t $1_t }, cupsd_t)
')

')
#
# Macros for mount
#
# Author:  Brian May <bam@snoopy.apana.org.au>
# Extended by Russell Coker <russell@coker.com.au>
#

#
# mount_domain(domain_prefix,dst_domain_prefix)
#
# Define a derived domain for the mount program for anyone.
#
define(`mount_domain', `
#
# Rules for the $2_t domain, used by the $1_t domain.
#
# $2_t is the domain for the mount process.
#
# This macro will not be included by all users and it may be included twice if
# called from other macros, so we need protection for this do not call this
# macro if $2_def is defined
define(`$2_def', `')
#
type $2_t, domain, privlog;

every_domain($2_t)
# when mount is run by $1 goto $2_t domain
domain_auto_trans($1_t, mount_exec_t, $2_t)

tmp_domain($2)

# Use capabilities.
allow $2_t self:capability { net_bind_service sys_rawio sys_admin };

# Create and modify /etc/mtab.
file_type_auto_trans($2_t, etc_t, etc_runtime_t, file)

# Access the terminal.
allow $2_t $1_tty_device_t:chr_file { getattr read write ioctl };
allow $2_t $1_devpts_t:chr_file { getattr read write };
ifdef(`gnome-pty-helper.te', `allow $2_t $1_gph_t:fd use;')
')
#
# Macros for MTA domains.
#

#
# Author:   Russell Coker <russell@coker.com.au>
# Based on the work of: Stephen Smalley <sds@epoch.ncsc.mil>
#                       Timothy Fraser 
#

#
# mail_domain(domain_prefix)
#
# Define a derived domain for the sendmail program when executed by
# a user domain to send outgoing mail.  These domains are separate and
# independent of the domain used for the sendmail daemon process.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/mta.te. 
#
undefine(`mail_domain')
define(`mail_domain',`
# Derived domain based on the calling user domain and the program.
type $1_mail_t, domain, privlog, user_mail_domain;

ifelse(`$1', `system', `
# Transition from a system domain to the derived domain.
domain_auto_trans_read(privmail, sendmail_exec_t, system_mail_t)
', `
# Transition from the user domain to the derived domain.
domain_auto_trans($1_t, sendmail_exec_t, $1_mail_t)
')
can_exec($1_mail_t, sendmail_exec_t)

# The user role is authorized for this domain.
role $1_r types $1_mail_t;

# This domain is granted permissions common to most domains (including can_net)
every_domain($1_mail_t)

# Use capabilities
allow $1_mail_t self:capability { setuid setgid chown };

# Execute procmail.
can_exec($1_mail_t, bin_t)
ifdef(`procmail.te',`
can_exec($1_mail_t, procmail_exec_t)')

ifelse(`$1', `system', `
# Read cron temporary files.
allow system_mail_t system_crond_tmp_t:file { read getattr };
allow mta_user_agent system_crond_tmp_t:file { read getattr };
allow system_mail_t initrc_devpts_t:chr_file { read write getattr };

', `
# Read user temporary files.
allow $1_mail_t $1_tmp_t:file { read getattr };
dontaudit $1_mail_t $1_tmp_t:file append;
ifdef(`postfix.te', `
# postfix seems to need write access if the file handle is opened read/write
allow $1_mail_t $1_tmp_t:file write;
')
allow mta_user_agent $1_tmp_t:file { read getattr };

allow mta_user_agent { $1_devpts_t $1_tty_device_t }:chr_file { getattr read write };

# Write to the user domain tty.
allow $1_mail_t $1_tty_device_t:chr_file rw_file_perms;
allow $1_mail_t $1_devpts_t:chr_file rw_file_perms;

# Inherit and use descriptors from gnome-pty-helper.
ifdef(`gnome-pty-helper.te', `allow $1_mail_t $1_gph_t:fd use;')

# Create dead.letter in user home directories.
file_type_auto_trans($1_mail_t, $1_home_dir_t, $1_home_t)

# if you do not want to allow dead.letter then use the following instead
#allow $1_mail_t { $1_home_dir_t $1_home_t }:dir r_dir_perms;
#allow $1_mail_t $1_home_t:file r_file_perms;

# for reading .forward - maybe we need a new type for it?
# also for delivering mail to maildir
file_type_auto_trans(mta_delivery_agent, $1_home_dir_t, $1_home_t)
')

ifdef(`qmail.te', `
allow $1_mail_t etc_qmail_t:dir search;
allow $1_mail_t etc_qmail_t:{ file lnk_file } read;
')

')
#
# Macros for netscape/mozilla (or other browser) domains.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser 
#

#
# netscape_domain(domain_prefix)
#
# Define a derived domain for the netscape/mozilla program when executed by
# a user domain.  
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/netscape.te. 
#
define(`netscape_domain',`
x_client_domain($1, netscape, `, privlog')

# Execute downloaded programs.
can_exec($1_netscape_t, $1_netscape_rw_t)

ifdef(`apache.te', `
# additions by Brian May <bam@snoopy.apana.org.au> 2002-07-16
allow $1_netscape_t httpd_t:tcp_socket { recvfrom connectto };
allow httpd_t $1_netscape_t:tcp_socket { recvfrom acceptfrom };
')

dontaudit $1_netscape_t $1_home_t:dir rw_dir_perms;
dontaudit $1_netscape_t $1_home_t:file rw_file_perms;

# Use printer
ifdef(`lpr.te', `domain_auto_trans($1_netscape_t, lpr_exec_t, $1_lpr_t)')

')dnl end netscape macro

# $1 is the source domain (or domains), $2 is the source role (or roles) and $3
# is the base name for the domain to run.  $1 is normally sysadm_t, and $2 is
# normally sysadm_r.  $4 is the type of program to run and $5 is the domain to
# transition to.
# sample usage:
# run_program(sysadm_t, sysadm_r, init, etc_t, initrc_t)
#
# if you have several users who run the same run_init type program for
# different purposes (think of a run_db program used by several database
# administrators to start several databases) then you can list all the source
# domains in $1, all the source roles in $2, but you may not want to list all
# types of programs to run in $4 and target domains in $5 (as that may permit
# entering a domain from the wrong type).  In such a situation just specify
# one value for each of $4 and $5 and have some rules such as the following:
# domain_trans(run_whatever_t, whatever_exec_t, whatever_t)

define(`run_program', `
type run_$3_exec_t, file_type, exec_type, sysadmfile;

# domain for program to run in, needs to change role (privrole), change
# identity to system_u (privuser), log failures to syslog (privlog) and
# authenticate users (auth)
type run_$3_t, domain, privrole, privuser, privlog, auth;
domain_auto_trans($1, run_$3_exec_t, run_$3_t)
role $2 types run_$3_t;

# for utmp
allow run_$3_t initrc_var_run_t:file rw_file_perms;
allow run_$3_t admin_tty_type:chr_file rw_file_perms;

# often the administrator runs such programs from a directory that is owned
# by a different user or has restrictive SE permissions, do not want to audit
# the failed access to the current directory
dontaudit run_$3_t file_type:dir search;
dontaudit run_$3_t self:capability { dac_override dac_read_search };

can_exec(run_$3_t, { bin_t chkpwd_exec_t shell_exec_t })

domain_trans(run_$3_t, $4, $5)

# hmm, do we REALLY need this?
every_domain(run_$3_t)
')
#
# Macros for screen domains.
#

#
# Author: Russell Coker <russell@coker.com.au>
# Based on the work of Stephen Smalley <sds@epoch.ncsc.mil>
# and Timothy Fraser
#

#
# screen_domain(domain_prefix)
#
# Define a derived domain for the screen program when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/screen.te. 
#
undefine(`screen_domain')
ifdef(`screen.te', `
define(`screen_domain',`
# Derived domain based on the calling user domain and the program.
type $1_screen_t, domain, privlog, auth;

allow $1_screen_t shadow_t:file { read getattr };

# Transition from the user domain to this domain.
domain_auto_trans($1_t, screen_exec_t, $1_screen_t)

# The user role is authorized for this domain.
role $1_r types $1_screen_t;

uses_shlib($1_screen_t)

# Revert to the user domain when a shell is executed.
domain_auto_trans($1_screen_t, shell_exec_t, $1_t)

# Inherit and use descriptors from gnome-pty-helper.
ifdef(`gnome-pty-helper.te',
`allow $1_screen_t $1_gph_t:fd use;
allow $1_t $1_gph_t:fd use;')

# Inherit and use descriptors from newrole.
ifdef(`newrole.te', `allow $1_screen_t newrole_t:fd use;')

# Inherit and use descriptors from sshd.
ifdef(`sshd.te', `allow $1_screen_t sshd_t:fd use;')

# Write to utmp.
allow $1_screen_t initrc_var_run_t:file rw_file_perms;
can_create_pty($1_screen)

# Create pid file.
allow $1_screen_t var_t:dir search;
type var_run_$1_screen_t, file_type, sysadmfile, pidfile;
file_type_auto_trans($1_screen_t, var_run_t, var_run_$1_screen_t)

# Use the network.
#can_network($1_screen_t)

# Write to the user domain tty.
allow $1_screen_t $1_tty_device_t:chr_file rw_file_perms;
allow $1_screen_t $1_devpts_t:chr_file rw_file_perms;

allow $1_screen_t self:process { fork sigchld signal };
allow $1_screen_t self:capability { setuid setgid fsetid };

# get stats
allow $1_screen_t proc_t:dir search;
allow $1_screen_t proc_t:lnk_file read;
allow $1_screen_t devpts_t:dir { getattr search read };
dontaudit $1_screen_t device_t:chr_file { getattr };
allow $1_screen_t etc_t:file { read getattr };
allow $1_screen_t self:dir { search read };
allow $1_screen_t self:lnk_file { read };
allow $1_screen_t device_t:filesystem getattr;
allow $1_screen_t $1_home_t:dir search;

allow $1_screen_t self:unix_stream_socket create_socket_perms;
can_exec($1_screen_t, shell_exec_t)

dontaudit $1_screen_t file_type:{ chr_file blk_file } getattr;
')

', `

define(`screen_domain',`')

')
#
# Macros for sendmail domains.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser 
#           Russell Coker <russell@coker.com.au>
#

#
# sendmail_user_domain(domain_prefix)
#
# Define a derived domain for the sendmail program when executed by
# a user domain to send outgoing mail.  These domains are separate and
# independent of the domain used for the sendmail daemon process.
#
undefine(`sendmail_user_domain')
define(`sendmail_user_domain', `

# Use capabilities
allow $1_mail_t self:capability net_bind_service;

# Type for temporary files.
type $1_mail_tmp_t, file_type, sysadmfile, tmpfile;
# Use this type when creating files in /tmp.
file_type_auto_trans($1_mail_t, tmp_t, $1_mail_tmp_t)

# Update /etc/mail/statistics.
allow $1_mail_t etc_mail_t:file rw_file_perms;

# Write to /var/spool/mail and /var/spool/mqueue.
allow $1_mail_t mail_spool_t:dir rw_dir_perms;
allow $1_mail_t mail_spool_t:file create_file_perms;
allow $1_mail_t mqueue_spool_t:dir rw_dir_perms;
allow $1_mail_t mqueue_spool_t:file create_file_perms;

# Write to /var/log/sendmail.st
file_type_auto_trans($1_mail_t, var_log_t, sendmail_var_log_t)

')

#
# Macros for ssh domains.
#

#
# Author:  Stephen Smalley <sds@epoch.ncsc.mil>
#

# 
# ssh_domain(domain_prefix)
#
# Define a derived domain for the ssh program when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/ssh.te. 
#
undefine(`ssh_domain')
ifdef(`ssh.te',
`
define(`ssh_domain',`
# Derived domain based on the calling user domain and the program.
type $1_ssh_t, domain, privlog;

# Transition from the user domain to the derived domain.
domain_auto_trans($1_t, ssh_exec_t, $1_ssh_t)

# The user role is authorized for this domain.
role $1_r types $1_ssh_t;

# Grant permissions within the domain.
general_domain_access($1_ssh_t)

# Use descriptors created by sshd
allow $1_ssh_t privfd:fd use;

uses_shlib($1_ssh_t)

# read localization information
allow $1_ssh_t locale_t:dir r_dir_perms;
allow $1_ssh_t locale_t:{file lnk_file} r_file_perms;

# Get attributes of file systems.
allow $1_ssh_t fs_type:filesystem getattr;

base_file_read_access($1_ssh_t)

# Read the devpts root directory.
allow $1_ssh_t devpts_t:dir r_dir_perms;

# Read /var.
allow $1_ssh_t var_t:dir r_dir_perms;
allow $1_ssh_t var_t:notdevfile_class_set r_file_perms;

# Read /var/run, /var/log.
allow $1_ssh_t var_run_t:dir r_dir_perms;
allow $1_ssh_t var_run_t:{ file lnk_file } r_file_perms;
allow $1_ssh_t var_log_t:dir r_dir_perms;
allow $1_ssh_t var_log_t:{ file lnk_file } r_file_perms;

# Read /etc.
allow $1_ssh_t etc_t:dir r_dir_perms;
allow $1_ssh_t etc_t:notdevfile_class_set r_file_perms;
allow $1_ssh_t etc_runtime_t:{ file lnk_file } r_file_perms;
allow $1_ssh_t resolv_conf_t:{ file lnk_file } r_file_perms;

# Read the linker, shared library, and executable types.
allow $1_ssh_t ld_so_t:{ file lnk_file } r_file_perms;
allow $1_ssh_t shlib_t:{ file lnk_file } r_file_perms;
allow $1_ssh_t exec_type:{ file lnk_file } r_file_perms;

# Read /dev directories and any symbolic links.
allow $1_ssh_t device_t:dir r_dir_perms;
allow $1_ssh_t device_t:lnk_file r_file_perms;

# Read /dev/random.
allow $1_ssh_t random_device_t:chr_file r_file_perms;

# Read and write /dev/tty and /dev/null.
allow $1_ssh_t devtty_t:chr_file rw_file_perms;
allow $1_ssh_t { null_device_t zero_device_t }:chr_file rw_file_perms;

# Grant permissions needed to create TCP and UDP sockets and
# to access the network.
can_network($1_ssh_t)

# for sshing to a ssh tunnel
can_tcp_connect($1_ssh_t, $1_ssh_t)

# Use capabilities.
allow $1_ssh_t self:capability { setuid setgid dac_override dac_read_search };

# Run helpers.
can_exec_any($1_ssh_t)

# Read the ssh key file.
allow $1_ssh_t sshd_key_t:file r_file_perms;

# Access the ssh temporary files.
file_type_auto_trans($1_ssh_t, tmp_t, sshd_tmp_t)
allow $1_ssh_t $1_tmp_t:dir r_dir_perms;

# for rsync
allow $1_ssh_t $1_t:unix_stream_socket rw_socket_perms;

# Access the users .ssh directory.
type $1_home_ssh_t, file_type, sysadmfile;
file_type_auto_trans({ sysadm_ssh_t $1_ssh_t }, $1_home_dir_t, $1_home_ssh_t)
allow { sysadm_ssh_t $1_ssh_t } $1_home_ssh_t:lnk_file { getattr read };
dontaudit $1_ssh_t $1_home_t:dir search;
r_dir_file(sshd_t, $1_home_ssh_t)
rw_dir_create_file($1_t, $1_home_ssh_t)

# Inherit and use descriptors from gnome-pty-helper.
ifdef(`gnome-pty-helper.te', `allow $1_ssh_t $1_gph_t:fd use;')

# Connect to sshd.
can_tcp_connect($1_ssh_t, sshd_t)

# Write to the user domain tty.
allow $1_ssh_t $1_tty_device_t:chr_file rw_file_perms;
allow $1_ssh_t $1_devpts_t:chr_file rw_file_perms;

# Allow the user shell to signal the ssh program.
allow $1_t $1_ssh_t:process signal;
# allow ps to show ssh
allow $1_t $1_ssh_t:dir { search getattr read };
allow $1_t $1_ssh_t:{ file lnk_file } { read getattr };

# Allow the ssh program to communicate with ssh-agent.
allow $1_ssh_t $1_tmp_t:sock_file write;
allow $1_ssh_t $1_t:unix_stream_socket connectto;
allow $1_ssh_t sshd_t:unix_stream_socket connectto;

ifdef(`xserver.te', `
# Communicate with the X server.
can_unix_connect($1_ssh_t, $1_xserver_t)
allow $1_ssh_t $1_xserver_tmp_t:sock_file rw_file_perms;
allow $1_ssh_t { initrc_xserver_tmp_t $1_xserver_tmp_t }:dir search;
')

ifdef(`xdm.te', `
# should be able to remove these two later
allow $1_ssh_t xdm_xserver_tmp_t:sock_file { read write };
allow $1_ssh_t xdm_xserver_tmp_t:dir search;
allow $1_ssh_t xdm_xserver_t:unix_stream_socket connectto;
allow $1_ssh_t xdm_xserver_t:shm { read unix_read getattr associate };
allow $1_ssh_t xdm_xserver_t:fd use;
allow $1_ssh_t xdm_xserver_tmpfs_t:file read;
')

')dnl  end of ifdef ssh.te


', `

define(`ssh_domain',`')

')
#
# Macros for su domains.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser
#

#
# su_domain(domain_prefix)
#
# Define a derived domain for the su program when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/su.te. 
#
undefine(`su_mini_domain')
undefine(`su_domain')
ifdef(`su.te', `
define(`su_mini_domain', `
# Derived domain based on the calling user domain and the program.
type $1_su_t, domain, privlog, auth;

# Transition from the user domain to this domain.
domain_auto_trans($1_t, su_exec_t, $1_su_t)

# This domain is granted permissions common to most domains.
every_domain($1_su_t)

# Use capabilities.
allow $1_su_t self:capability { setuid setgid net_bind_service chown dac_override sys_nice sys_resource };

# Revert to the user domain when a shell is executed.
domain_auto_trans($1_su_t, shell_exec_t, $1_t)

allow $1_su_t privfd:fd use;

# Write to utmp.
allow $1_su_t initrc_var_run_t:file rw_file_perms;

')dnl end su_mini_domain

define(`su_domain', `
su_mini_domain($1)
ifdef(`chkpwd.te', `
# Run chkpwd.
can_exec($1_su_t, chkpwd_exec_t)
')

# Inherit and use descriptors from gnome-pty-helper.
ifdef(`gnome-pty-helper.te', `
allow { $1_su_t $1_t } $1_gph_t:fd use;
')

# The user role is authorized for this domain.
role $1_r types $1_su_t;

# Write to the user domain tty.
allow $1_su_t $1_tty_device_t:chr_file rw_file_perms;
allow $1_su_t $1_devpts_t:chr_file rw_file_perms;

allow $1_su_t $1_home_dir_t:dir search;

# Modify .Xauthority file (via xauth program).
ifdef(`xauth.te', `
domain_auto_trans($1_su_t, xauth_exec_t, $1_xauth_t)
')

# Access sshd cookie files.
allow $1_su_t sshd_tmp_t:dir rw_dir_perms;
allow $1_su_t sshd_tmp_t:file rw_file_perms;
file_type_auto_trans($1_su_t, sshd_tmp_t, $1_tmp_t)

# stop su complaining if you run it from a directory with restrictive perms
dontaudit $1_su_t file_type:dir search;
')dnl end su_domain

', `

define(`su_domain',`')

')
#
# Macros for xauth domains.
#

#
# Author:  Russell Coker <russell@coker.com.au>
#

#
# xauth_domain(domain_prefix)
#
# Define a derived domain for the xauth program when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/xauth.te. 
#
undefine(`xauth_domain')
ifdef(`xauth.te', `
define(`xauth_domain',`
# Derived domain based on the calling user domain and the program.
type $1_xauth_t, domain;
type $1_home_xauth_t, file_type, sysadmfile;

allow $1_t $1_home_xauth_t:file { relabelfrom relabelto create_file_perms };

# Transition from the user domain to this domain.
domain_auto_trans($1_t, xauth_exec_t, $1_xauth_t)
ifdef(`ssh.te', `
domain_auto_trans($1_ssh_t, xauth_exec_t, $1_xauth_t)
allow $1_xauth_t sshd_t:fifo_file { getattr read };
dontaudit $1_xauth_t $1_ssh_t:tcp_socket { read write };
allow $1_xauth_t sshd_t:process sigchld;
')

ifdef(`su.te', `
domain_auto_trans($1_su_t, xauth_exec_t, $1_xauth_t)
')

# The user role is authorized for this domain.
role $1_r types $1_xauth_t;

# Inherit and use descriptors from gnome-pty-helper.
ifdef(`gnome-pty-helper.te', `
allow $1_xauth_t $1_gph_t:fd use;
')

allow $1_xauth_t privfd:fd use;

# allow ps to show xauth
allow $1_t $1_xauth_t:dir { search getattr read };
allow $1_t $1_xauth_t:{ file lnk_file } { read getattr };
allow $1_t $1_xauth_t:process signal;

uses_shlib($1_xauth_t)

# allow DNS lookups...
can_network($1_xauth_t)
ifdef(`named.te', `
can_udp_send($1_xauth_t, named_t)
can_udp_send(named_t, $1_xauth_t)
')

#allow $1_xauth_t devpts_t:dir { getattr read search };
#allow $1_xauth_t device_t:dir search;
#allow $1_xauth_t devtty_t:chr_file rw_file_perms;
allow $1_xauth_t self:unix_stream_socket create_stream_socket_perms;
allow $1_xauth_t { etc_t resolv_conf_t }:file { getattr read };
allow $1_xauth_t fs_t:filesystem getattr;

#allow $1_xauth_t proc_t:dir search;
#allow $1_xauth_t { self proc_t }:lnk_file read;
#allow $1_xauth_t self:dir search;
#dontaudit $1_xauth_t var_run_t:dir search;

# Write to the user domain tty.
allow $1_xauth_t $1_tty_device_t:chr_file rw_file_perms;
allow $1_xauth_t $1_devpts_t:chr_file rw_file_perms;

# allow utmp access
#allow $1_xauth_t initrc_var_run_t:file read;
#dontaudit $1_xauth_t initrc_var_run_t:file lock;

# Scan /var/run.
allow $1_xauth_t var_t:dir search;
allow $1_xauth_t var_run_t:dir search; 

# this is what we are here for
allow $1_xauth_t home_root_t:dir search;
file_type_auto_trans($1_xauth_t, $1_home_dir_t, $1_home_xauth_t, file)

')

', `

define(`xauth_domain',`')

')
#
# Macros for X client programs ($2 etc)
#

#
# Author: Russell Coker <russell@coker.com.au>
# Based on the work of Stephen Smalley <sds@epoch.ncsc.mil>
# and Timothy Fraser 
#

#
# x_client_domain(domain_prefix)
#
# Define a derived domain for an X program when executed by
# a user domain.  
#
# The type declaration for the executable type for this program ($2_exec_t)
# must be provided separately!
#
# The first parameter is the base name for the domain/role (EG user or sysadm)
# The second parameter is the program name (EG $2)
# The third parameter is the attributes for the domain (if any)
#
define(`x_client_domain',`
# Derived domain based on the calling user domain and the program.
type $1_$2_t, domain $3;

# Transition from the user domain to the derived domain.
domain_auto_trans($1_t, $2_exec_t, $1_$2_t)

# The user role is authorized for this domain.
role $1_r types $1_$2_t;

# This domain is granted permissions common to most domains (including can_net)
every_domain($1_$2_t)

# Type for files that are writeable by this domain.
type $1_$2_rw_t, file_type, sysadmfile, tmpfile;
# Use this type for files created in /tmp.
file_type_auto_trans($1_$2_t, tmp_t, $1_$2_rw_t)

allow $1_$2_t $1_home_xauth_t:file { getattr read };

# Allow the user domain to relabel to or create files with this type
# to provide the domain with write access to particular files.
allow $1_t $1_$2_rw_t:{ dir file lnk_file } { relabelfrom relabelto };
# allow $1_t to create dirs and files in the rw type (the auto_trans rule above
# does it for $1_$2_t)
allow $1_t $1_$2_rw_t:dir create_dir_perms;
allow $1_t $1_$2_rw_t:{ file lnk_file } create_file_perms;

# Type for files that are read-only for this domain
type $1_$2_ro_t, file_type, sysadmfile;
r_dir_file($1_$2_t, $1_$2_ro_t)
allow $1_$2_t $1_$2_ro_t:fifo_file { read write };
create_dir_file($1_t, $1_$2_ro_t)
allow $1_t $1_$2_ro_t:fifo_file create_file_perms;
allow $1_t $1_$2_ro_t:{ dir file lnk_file } { relabelto relabelfrom };

# Allow the user domain to send any signal to the $2 process.
allow $1_t $1_$2_t:process signal_perms;

# Allow the user domain to read the /proc/PID directory for 
# the $2 process.
allow $1_t $1_$2_t:dir r_dir_perms;
allow $1_t $1_$2_t:notdevfile_class_set r_file_perms;

# Allow use of /dev/zero by ld.so.
allow $1_$2_t zero_device_t:chr_file rw_file_perms;
allow $1_$2_t zero_device_t:chr_file x_file_perms;

# Execute system programs.
can_exec_any($1_$2_t)

# Inherit and use descriptors from gnome-pty-helper.
ifdef(`gnome-pty-helper.te', `allow $1_$2_t $1_gph_t:fd use;')

# Connect to sshd.
ifdef(`sshd.te', `can_tcp_connect($1_$2_t, sshd_t)')

# Allow connections to X server.
ifdef(`xserver.te', `
# for when /tmp/.X11-unix is created by the X server
allow $1_$2_t $1_xserver_tmp_t:dir search;
# for when /tmp/.X11-unix is created by the system
allow $1_$2_t initrc_xserver_tmp_t:dir search;

# for /tmp/.X0-lock
allow $1_$2_t $1_xserver_tmp_t:file getattr;

allow $1_$2_t $1_xserver_tmp_t:sock_file rw_file_perms;
can_unix_connect($1_$2_t, $1_xserver_t)')

ifdef(`xdm.te', `
# Allow connections to X server run by an X Display Manager.
#allow $1_$2_t xdm_tmp_t:dir r_dir_perms;
#allow $1_$2_t xdm_tmp_t:sock_file rw_file_perms;
can_unix_connect($1_$2_t, xdm_xserver_t)
allow $1_$2_t xdm_xserver_tmp_t:dir search;
allow $1_$2_t xdm_xserver_tmp_t:sock_file { read write };
allow $1_$2_t xdm_t:fd use;
dontaudit $1_$2_t xdm_t:tcp_socket { read write };
# for X over a ssh tunnel
ifdef(`ssh.te', `
can_tcp_connect($1_$2_t, sshd_t)
')

# for .xsession-errors
dontaudit $1_$2_t $1_home_t:file write;
')

# Access the terminal.
allow $1_$2_t $1_tty_device_t:chr_file rw_file_perms;
allow $1_$2_t $1_devpts_t:chr_file rw_file_perms;

# Read the home directory, e.g. for .Xauthority and to get to config files
file_type_auto_trans($1_$2_t, $1_home_dir_t, $1_$2_rw_t)

# Use a separate type for tmpfs/shm pseudo files.
type $1_$2_tmpfs_t, file_type, sysadmfile;
file_type_auto_trans($1_$2_t, tmpfs_t, $1_$2_tmpfs_t)
allow $1_$2_tmpfs_t tmpfs_t:filesystem associate;

# Communicate via shared memory.
ifdef(`xserver.te', `
# Allow the $2 domain to signal the X server.
allow $1_$2_t $1_xserver_t:process signal;
# Use descriptors created by each other.
allow $1_$2_t $1_xserver_t:fd use;

allow $1_xserver_t $1_$2_t:fd use;
allow $1_xserver_t $1_$2_t:shm rw_shm_perms;
allow $1_xserver_t $1_$2_tmpfs_t:file rw_file_perms;
allow $1_$2_t $1_xserver_t:shm r_shm_perms;
allow $1_$2_t $1_xserver_tmpfs_t:file r_file_perms;
')dnl end xserver.te policy

')dnl end x_client macro
#
# Macros for X server domains.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser
#

#################################
#
# xserver_domain(domain_prefix)
#
# Define a derived domain for the X server when executed
# by a user domain (e.g. via startx).  See the xdm_t domain
# in domains/program/xdm.te if using an X Display Manager.
#
# The type declarations for the executable type for this program 
# and the log type are provided separately in domains/program/xserver.te. 
#
# FIXME!  The X server requires far too many privileges.
#
undefine(`xserver_domain')
ifdef(`xserver.te', `

define(`xserver_domain',`
# Derived domain based on the calling user domain and the program.
type $1_xserver_t, domain, privlog, privmem;

# Transition from the user domain to this domain.
domain_auto_trans($1_t, xserver_exec_t, $1_xserver_t)

ifelse($1, xdm, `
# The system role is authorised for the xdm domain
role system_r types $1_xserver_t;
', `
# The user role is authorized for this domain.
role $1_r types $1_xserver_t;
')dnl

uses_shlib($1_xserver_t)
can_network($1_xserver_t)

# for access within the domain
general_domain_access($1_xserver_t)

# for access to lots of base files
general_file_read_access($1_xserver_t)

allow $1_xserver_t proc_t:dir search;

# Use capabilities.
# allow setuid/setgid for the wrapper program to change UID
# sys_rawio is for iopl access - should not be needed for frame-buffer
# sys_admin, locking shared mem?  chowning IPC message queues or semaphores?
# admin of APM bios?
# sys_nice is so that the X server can set a negative nice value
allow $1_xserver_t self:capability { setuid setgid sys_rawio sys_admin sys_nice };
dontaudit $1_xserver_t self:capability { dac_override dac_read_search };

# memory_device_t access is needed if not using the frame buffer
dontaudit $1_xserver_t memory_device_t:chr_file read;
#allow $1_xserver_t memory_device_t:chr_file { rw_file_perms execute };
# net_bind_service is needed if you want your X server to allow TCP connections
# from other hosts, EG an XDM serving a network of X terms
# if you want good security you do not want this
# not sure why some people want chown, fsetid, and sys_tty_config.
#allow $1_xserver_t self:capability { net_bind_service chown fsetid sys_tty_config };
dontaudit $1_xserver_t self:capability chown;

allow $1_xserver_t mtrr_device_t:file rw_file_perms;
allow $1_xserver_t apm_bios_t:chr_file rw_file_perms;
allow $1_xserver_t framebuf_device_t:chr_file rw_file_perms;
allow $1_xserver_t devtty_t:chr_file rw_file_perms;
allow $1_xserver_t devtty_t:lnk_file read;

# Type for temporary files.
tmp_domain($1_xserver)
file_type_auto_trans($1_xserver_t, initrc_xserver_tmp_t, $1_xserver_tmp_t, sock_file)
allow $1_t initrc_xserver_tmp_t:dir r_dir_perms;

# Create files in /var/log with the xserver_var_log_t type.
file_type_auto_trans($1_xserver_t, var_log_t, xserver_var_log_t)

# Allow the user domain to signal the X server for termination.
allow $1_t $1_xserver_t:process signal;

# Allow the user domain to connect to the X server.
can_unix_connect($1_t, $1_xserver_t)
allow $1_t $1_xserver_tmp_t:sock_file rw_file_perms;
allow $1_t $1_xserver_tmp_t:dir r_dir_perms;

# Signal the user domain.
allow $1_xserver_t $1_t:process signal;

# Access AGP device.
allow $1_xserver_t agp_device_t:chr_file rw_file_perms;

# Access /proc/mtrr
allow $1_xserver_t proc_t:file rw_file_perms;

# Create and access /dev/dri devices.
allow $1_xserver_t dri_device_t:dir { setattr rw_dir_perms };
allow $1_xserver_t dri_device_t:chr_file create_file_perms;

# Access ttys.
ifelse($1, xdm, , `
allow $1_xserver_t $1_tty_device_t:chr_file { setattr rw_file_perms };
')
allow $1_xserver_t tty_device_t:chr_file { setattr rw_file_perms };

# Run helper programs in $1_xserver_t.
can_exec_any($1_xserver_t)

# Connect to xfs.
ifdef(`xfs.te',
`can_unix_connect($1_xserver_t, xfs_t)
allow $1_xserver_t xfs_tmp_t:dir r_dir_perms;
allow $1_xserver_t xfs_tmp_t:sock_file rw_file_perms;

# Bind to the X server socket in /tmp.
allow $1_xserver_t $1_xserver_tmp_t:unix_stream_socket name_bind;')

# Communicate via System V shared memory.
allow $1_xserver_t $1_t:shm rw_shm_perms;
allow $1_t $1_xserver_t:shm rw_shm_perms;
ifelse($1, xdm, `', `
allow $1_xserver_t $1_tmpfs_t:file rw_file_perms;
allow $1_t $1_xserver_tmpfs_t:file rw_file_perms;
')

# David Wheeler says he needs the following permission
# for his X server.  Something is wrong here - the shared
# memory pseudo file should be labeled $1_tmpfs_t and handled
# by the rule above.  Needs further investigation.
allow $1_xserver_t tmpfs_t:file rw_file_perms;

# Type for tmpfs/shm files.
type $1_xserver_tmpfs_t, file_type, sysadmfile;
# Use this type when creating tmpfs/shm objects.
file_type_auto_trans($1_xserver_t, tmpfs_t, $1_xserver_tmpfs_t)
allow $1_xserver_tmpfs_t tmpfs_t:filesystem associate;

# Use the mouse.
allow $1_xserver_t mouse_device_t:chr_file rw_file_perms;

ifelse($1, xdm, `
dontaudit xdm_xserver_t sysadm_home_dir_t:dir { read search };
', `
# Access the home directory.
allow $1_xserver_t $1_home_dir_t:dir { getattr read search };
file_type_auto_trans($1_xserver_t, $1_home_dir_t, $1_home_xauth_t, file)
')dnl end ifelse xdm

allow $1_xserver_t var_lib_xkb_t:dir rw_dir_perms;
allow $1_xserver_t var_lib_xkb_t:file create_file_perms;
')dnl end macro definition

', `

define(`xserver_domain',`')

')

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

############################################
#
# Device types
#

#
# device_t is the type of /dev.
#
type device_t, file_type;

#
# null_device_t is the type of /dev/null.
#
type null_device_t, file_type, mlstrustedobject;

#
# zero_device_t is the type of /dev/zero.
#
type zero_device_t, file_type, mlstrustedobject;

#
# console_device_t is the type of /dev/console.
#
type console_device_t, file_type;

#
# memory_device_t is the type of /dev/kmem,
# /dev/mem, and /dev/port.
#
type memory_device_t, file_type;

#
# random_device_t is the type of /dev/urandom
# and /dev/random.
#
type random_device_t, file_type;

#
# devtty_t is the type of /dev/tty.
#
type devtty_t, file_type, mlstrustedobject;

#
# tty_device_t is the type of /dev/*tty*
#
type tty_device_t, file_type;

#
# fixed_disk_device_t is the type of 
# /dev/hd* and /dev/sd*.
#
type fixed_disk_device_t, file_type;

#
# removable_device_t is the type of
# /dev/scd* and /dev/fd*.
#
type removable_device_t, file_type;

#
# clock_device_t is the type of
# /dev/rtc.
#
type clock_device_t, file_type;

#
# tun_tap_device_t is the type of /dev/net/tun/* and /dev/net/tap/*
#
type tun_tap_device_t, file_type;

#
# misc_device_t is the type of miscellaneous devices.
# XXX:  FIXME!  Appropriate access to these devices need to be identified.
#
type misc_device_t, file_type;

#
# psaux_t is the type of the /dev/psaux mouse device.
# This type is deprecated and will be removed.
#
type psaux_t, file_type;

#
# A more general type for mouse devices.
#
type mouse_device_t, file_type;

#
# Not sure what these devices are for, but X wants access to them.
#
type agp_device_t, file_type;
type dri_device_t, file_type;

# Type for sound devices.
type sound_device_t, file_type;

# Type for /dev/ppp.
type ppp_device_t, file_type;

# Type for frame buffer /dev/fb/*
type framebuf_device_t, file_type;

# Type for /dev/.devfsd
type devfs_control_t, file_type;

# Type for /dev/cpu/mtrr
type mtrr_device_t, file_type;


# Type for /dev/apm_bios
type apm_bios_t, file_type;

# Type for v4l
type v4l_device_t, file_type;
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

############################################
#
# Devpts types
#

#
# ptmx_t is the type for /dev/ptmx.
#
type ptmx_t, file_type, sysadmfile;

#
# devpts_t is the type of the devpts file system and 
# the type of the root directory of the file system.
#
type devpts_t, fs_type, root_dir_type;


#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

#######################################
#
# General file-related types
#

#
# unlabeled_t is the type of unlabeled objects.
# Eventually, once all objects are labeled and 
# controlled by the security policy, unlabeled_t 
# will not be used.
#
type unlabeled_t, fs_type, file_type, root_dir_type, sysadmfile;

#
# fs_t is the default type of an unlabeled
# file system.  When an unlabeled file system is
# mounted read-write, the file system is labeled
# with this type.  Except for the root file system,
# other types may be specified using the fs_contexts
# or fs_contexts.mls file.
#
type fs_t, fs_type;

#
# file_t is the default type of an unlabeled
# file.  When an unlabeled file system is mounted
# read-write, all files in the file system are labeled
# with this type.   Except for the root file system,
# other types may be specified using the fs_contexts
# or fs_contexts.mls file.
#
type file_t, file_type, root_dir_type, sysadmfile;

#
# root_t is the type for the root directory.
#
type root_t, file_type, sysadmfile;

#
# home_root_t is the type for the directory where user home directories
# are created
#
type home_root_t, file_type, sysadmfile;

#
# lost_found_t is the type for the lost+found directories.
#
type lost_found_t, file_type, sysadmfile;

#
# boot_t is the type for files in /boot,
# including the kernel.
#
type boot_t, file_type, root_dir_type, sysadmfile;
# system_map_t is for the system.map files in /boot
type system_map_t, file_type, sysadmfile;

#
# boot_runtime_t is the type for /boot/kernel.h,
# which is automatically generated at boot time.
# only for red hat
type boot_runtime_t, file_type, sysadmfile;

#
# tmp_t is the type of /tmp and /var/tmp.
#
type tmp_t, file_type, sysadmfile, tmpfile;

#
# etc_t is the type of the system etc directories.
#
type etc_t, file_type, sysadmfile;
#
# shadow_t is the type of the /etc/shadow file
#
type shadow_t, file_type;
allow auth shadow_t:file { getattr read };

#
# ld_so_cache_t is the type of /etc/ld.so.cache.
#
type ld_so_cache_t, file_type, sysadmfile;

#
# etc_runtime_t is the type of various
# files in /etc that are automatically
# generated during initialization.
#
type etc_runtime_t, file_type, sysadmfile;

#
# etc_aliases_t is the type of the aliases database.
# etc_mail_t is the type of /etc/mail.
# sendmail needs write access to these files.
#
type etc_aliases_t, file_type, sysadmfile;
type etc_mail_t, file_type, sysadmfile;

# resolv_conf_t is the type of the /etc/resolv.conf file.
# pump needs write access to this file.
type resolv_conf_t, file_type, sysadmfile;

#
# lib_t is the type of files in the system lib directories.
#
type lib_t, file_type, sysadmfile;

#
# shlib_t is the type of shared objects in the system lib
# directories.
#
type shlib_t, file_type, sysadmfile;

#
# ld_so_t is the type of the system dynamic loaders.
#
type ld_so_t, file_type, sysadmfile;

#
# bin_t is the type of files in the system bin directories.
#
type bin_t, file_type, sysadmfile;

#
# ls_exec_t is the type of the ls program.
#
type ls_exec_t, file_type, exec_type, sysadmfile;

#
# shell_exec_t is the type of user shells such as /bin/bash.
#
type shell_exec_t, file_type, exec_type, sysadmfile;

#
# sbin_t is the type of files in the system sbin directories.
#
type sbin_t, file_type, sysadmfile;

#
# usr_t is the type for /usr.
#
type usr_t, file_type, root_dir_type, sysadmfile;

#
# src_t is the type of files in the system src directories.
#
type src_t, file_type, sysadmfile;

#
# var_t is the type for /var.
#
type var_t, file_type, root_dir_type, sysadmfile;

#
# Types for subdirectories of /var.
#
type var_run_t, file_type, sysadmfile;
type var_log_t, file_type, sysadmfile, logfile;
type faillog_t, file_type, sysadmfile, logfile;
type var_lock_t, file_type, sysadmfile, lockfile;
type var_lib_t, file_type, sysadmfile;
# for /var/{spool,lib}/texmf index files
type tetex_data_t, file_type, sysadmfile, tmpfile;
type var_spool_t, file_type, sysadmfile;
type var_yp_t, file_type, sysadmfile;

# Type for /var/log/sa.
type var_log_sa_t, file_type, sysadmfile, logfile;

# Type for /var/log/ksyms.
type var_log_ksyms_t, file_type, sysadmfile, logfile;

# Type for /var/log/lastlog.
type lastlog_t, file_type, sysadmfile, logfile;

# Type for /var/lib/nfs.
type var_lib_nfs_t, file_type, sysadmfile;

#
# wtmp_t is the type of /var/log/wtmp.
#
type wtmp_t, file_type, sysadmfile, logfile;

#
# catman_t is the type for /var/catman.
#
type catman_t, file_type, sysadmfile, tmpfile;

#
# at_spool_t is the type for /var/spool/at.
#
type at_spool_t, file_type, sysadmfile;

#
# cron_spool_t is the type for /var/spool/cron.
#
type cron_spool_t, file_type, sysadmfile;

#
# print_spool_t is the type for /var/spool/lpd and /var/spool/cups.
#
type print_spool_t, file_type, sysadmfile;

#
# mail_spool_t is the type for /var/spool/mail.
#
type mail_spool_t, file_type, sysadmfile;

#
# mqueue_spool_t is the type for /var/spool/mqueue.
#
type mqueue_spool_t, file_type, sysadmfile;

#
# man_t is the type for the man directories.
#
type man_t, file_type, sysadmfile;

#
# readable_t is a general type for
# files that are readable by all domains.
#
type readable_t, file_type, sysadmfile;

# 
# Base type for the tests directory.
# 
type test_file_t, file_type, sysadmfile;

#
# poly_t is the type for the polyinstantiated directories.
#
type poly_t, file_type, sysadmfile;

#
# swapfile_t is for swap files
#
type swapfile_t, file_type, sysadmfile;

#
# locale_t is the type for system localization
# 
type locale_t, file_type;

#
# Allow each file type to be associated with 
# the default file system type.
#
allow file_type fs_t:filesystem associate;

# Allow the pty to be associated with the file system.
allow devpts_t devpts_t:filesystem associate;

type tmpfs_t, file_type, sysadmfile, fs_type, root_dir_type;
allow { tmpfs_t tmp_t } tmpfs_t:filesystem associate;

type usbdevfs_t, fs_type, root_dir_type, sysadmfile;
allow usbdevfs_t usbdevfs_t:filesystem associate;
type usbdevfs_device_t, file_type, sysadmfile;
allow usbdevfs_device_t usbdevfs_t:filesystem associate;

type sysfs_t alias driverfs_t, fs_type, root_dir_type, sysadmfile;
allow sysfs_t sysfs_t:filesystem associate;

type iso9660_t, fs_type, root_dir_type, sysadmfile;
allow iso9660_t iso9660_t:filesystem associate;

type dosfs_t, fs_type, root_dir_type, sysadmfile;
allow dosfs_t dosfs_t:filesystem associate;
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

# Modified by Reino Wallin <reino@oribium.com>
# Multi NIC, and IPSEC features

# Modified by Russell Coker
# Move port types to their respective domains, add ifdefs, other cleanups.

############################################
#
# Network types
#

# 
# any_socket_t is the default destination
# socket type for UDP traffic.  Unless a 
# destination socket type is explicitly specified
# using sendto_secure/sendmsg_secure, this type
# is used for the udp_socket sendto permission check.
#
type any_socket_t, socket_type;
role system_r types any_socket_t;

#
# igmp_packet_t is the type of kernel-generated IGMP packets.
# icmp_socket_t is the type of the kernel socket used to send ICMP messages.
# tcp_socket_t is the type of the kernel socket used to send TCP resets.
# scmp_packet_t is the type for SCMP packets used by the SELOPT packet labeling.
#
type igmp_packet_t;
role system_r types igmp_packet_t;
type icmp_socket_t, socket_type;
role system_r types icmp_socket_t;
type tcp_socket_t, socket_type;
role system_r types tcp_socket_t;
type scmp_packet_t;
role system_r types scmp_packet_t;

#
# port_t is the default type of INET port numbers.
# The *_port_t types are used for specific port
# numbers in net_contexts or net_contexts.mls.
#
type port_t, port_type;

#
# netif_t is the default type of network interfaces.
# The netif_*_t types are used for specific network
# interfaces in net_contexts or net_contexts.mls.
#
type netif_t, netif_type;
type netif_eth0_t, netif_type;
type netif_eth1_t, netif_type;
type netif_eth2_t, netif_type;
type netif_lo_t, netif_type;
type netif_ippp0_t, netif_type;

type netif_ipsec0_t, netif_type;
type netif_ipsec1_t, netif_type;
type netif_ipsec2_t, netif_type;

#
# netmsg_t is the default type of unlabeled received messages.
# The netmsg_*_t types are used for specific network
# interfaces in net_contexts or net_contexts.mls.
#
type netmsg_t, netmsg_type;
type netmsg_eth0_t, netmsg_type;
type netmsg_eth1_t, netmsg_type;
type netmsg_eth2_t, netmsg_type;
type netmsg_lo_t, netmsg_type;
type netmsg_ippp0_t, netmsg_type;

type netmsg_ipsec0_t, netmsg_type;
type netmsg_ipsec1_t, netmsg_type;
type netmsg_ipsec2_t, netmsg_type;

#
# node_t is the default type of network nodes.
# The node_*_t types are used for specific network
# nodes in net_contexts or net_contexts.mls.
#
type node_t, node_type;
type node_lo_t, node_type;
type node_internal_t, node_type;

#
# Permissions for the kernel-generated IGMP packets.
#
allow igmp_packet_t netif_type:netif { rawip_send rawip_recv };
allow igmp_packet_t node_type:node { rawip_send rawip_recv };

#
# Permissions for the kernel ICMP socket.
#
allow icmp_socket_t netif_type:netif { rawip_send rawip_recv };
allow icmp_socket_t node_type:node { rawip_send rawip_recv };
allow icmp_socket_t netmsg_type:rawip_socket recvfrom;

#
# Permissions for the kernel TCP reset socket.
#
allow tcp_socket_t netif_type:netif { tcp_send tcp_recv };
allow tcp_socket_t netmsg_type:tcp_socket recvfrom;
allow tcp_socket_t node_type:node { tcp_send tcp_recv };

#
# Allow network messages to be received.
#
allow netmsg_t node_t:node { tcp_recv udp_recv rawip_recv };
allow netmsg_eth0_t node_t:node { tcp_recv udp_recv rawip_recv };
allow netmsg_eth0_t netif_eth0_t:netif { tcp_recv udp_recv rawip_recv };
allow netmsg_eth1_t node_t:node { tcp_recv udp_recv rawip_recv };
allow netmsg_eth1_t netif_eth1_t:netif { tcp_recv udp_recv rawip_recv };
allow netmsg_eth2_t node_t:node { tcp_recv udp_recv rawip_recv };
allow netmsg_eth2_t netif_eth2_t:netif { tcp_recv udp_recv rawip_recv };
allow netmsg_lo_t node_lo_t:node { tcp_recv udp_recv rawip_recv };
allow netmsg_lo_t node_t:node { tcp_recv udp_recv rawip_recv };
allow netmsg_lo_t netif_lo_t:netif { tcp_recv udp_recv rawip_recv };
allow netmsg_ippp0_t node_t:node { tcp_recv udp_recv rawip_recv };
allow netmsg_ippp0_t netif_ippp0_t:netif { tcp_recv udp_recv rawip_recv };
allow netmsg_ipsec0_t node_t:node { tcp_recv udp_recv rawip_recv };
allow netmsg_ipsec0_t netif_ipsec0_t:node { tcp_recv udp_recv rawip_recv };
allow netmsg_ipsec1_t node_t:node { tcp_recv udp_recv rawip_recv };
allow netmsg_ipsec1_t netif_ipsec1_t:netif { tcp_recv udp_recv rawip_recv };
allow netmsg_ipsec2_t node_t:node { tcp_recv udp_recv rawip_recv };
allow netmsg_ipsec2_t netif_ipsec2_t:netif { tcp_recv udp_recv rawip_recv };

#
# Allow ICMP echo requests to be sent and received, and echo replies to 
# be received (when packets are labeled)
#
ifdef(`ping.te',
`allow ping_t netif_type:netif { rawip_send rawip_recv };
allow ping_t node_type:node { rawip_send rawip_recv };
allow ping_t netmsg_type:rawip_socket { recvfrom };')
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

#############################################
#
# NFS types
#

#
# nfs_t is the default type for NFS file systems 
# and their files.  
# The nfs_*_t types are used for specific NFS
# servers in net_contexts or net_contexts.mls.
#
type nfs_t, fs_type, root_dir_type;

#
# Allow NFS files to be associated with an NFS file system.
#
allow nfs_t nfs_t:filesystem associate;
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

############################################
#
# Procfs types
#

#
# proc_t is the type of /proc.
# proc_kmsg_t is the type of /proc/kmsg.
# proc_kcore_t is the type of /proc/kcore.
#
type proc_t, fs_type, root_dir_type;
type proc_kmsg_t;
type proc_kcore_t;

#
# sysctl_t is the type of /proc/sys.
# sysctl_fs_t is the type of /proc/sys/fs.
# sysctl_kernel_t is the type of /proc/sys/kernel.
# sysctl_modprobe_t is the type of /proc/sys/kernel/modprobe.
# sysctl_net_t is the type of /proc/sys/net.
# sysctl_net_unix_t is the type of /proc/sys/net/unix.
# sysctl_vm_t is the type of /proc/sys/vm.
# sysctl_dev_t is the type of /proc/sys/dev.
#
# These types are applied to both the entries in
# /proc/sys and the corresponding sysctl parameters.
#
type sysctl_t;
type sysctl_fs_t;
type sysctl_kernel_t;
type sysctl_modprobe_t;
type sysctl_net_t;
type sysctl_net_unix_t;
type sysctl_vm_t;
type sysctl_dev_t;


#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

############################################
#
# Security types
#

# 
# security_t is the target type when checking
# most of the permissions in the security class.
# The two exceptions are sid_to_context and load_policy.
# The sid_to_context permission uses the type attribute
# of the SID parameter, and the load_policy permission
# uses the type of the policy file.
#
type security_t;

#
# policy_config_t is the type of /ss_policy,
# the security server policy configuration.
#
type policy_config_t, file_type;

#
# policy_src_t is the type of the policy source
# files.
#
type policy_src_t, file_type;

#
# default_context_t is the type applied to 
# /etc/security/default_context
#
type default_context_t, file_type, sysadmfile, login_contexts;

#
# file_labels_t is the type of the persistent
# label mapping stored in each file system.
# The mapping files are in the ...security
# subdirectory at the root of each file system.
#
type file_labels_t, file_type, sysadmfile;

#
# no_access_t is the type for objects that should
# only be accessed administratively. 
#
type no_access_t, file_type, sysadmfile;


#DESC Admin - Domains for administrators.
#
#################################

# sysadm_t is the system administrator domain.
type sysadm_t, domain, privlog, privowner, admin, userdomain, privhome;
allow privhome home_root_t:dir search;

# system_r is authorized for sysadm_t for single-user mode.
role system_r types sysadm_t; 

# sysadm_r is authorized for sysadm_t for the initial login domain.
role sysadm_r types sysadm_t;

# sysadm_t is granted the permissions common to most domains.
every_domain(sysadm_t)

# sysadm_t is also granted permissions specific to administrator domains.
admin_domain(sysadm)

# Audit grantings of avc_toggle to the administrator domains.
# Due to its sensitivity, we always audit this permission.
auditallow admin kernel_t:system avc_toggle;


define(`admin_tty_type', `{ sysadm_tty_device_t sysadm_devpts_t }')

allow sysadm_t var_spool_t:file { execute };
#allow sysadm_t sysadm_home_dir_t:dir { add_name read remove_name write };
#allow sysadm_t sysadm_home_dir_t:file { create getattr link read unlink write };

allow sysadm_t usr_t:file { execute };

allow sysadm_t sysadm_t:packet_socket { create bind getopt ioctl read setopt };








#DESC Httpd admin -  Domain for httpd administrators
########################################
# httpd_admin domain macro and rules for 
# httpd_admin_t
########################################

# Uses some types defined in apache.te, so conditionally defined this macro.
# The intent is to remove this file in the future.
#
ifdef(`apache.te', `

include(user_macros.te)

define(`httpd_admin_domain',`

################################
# Allow httpd_admin_t to do everything user_t can do
#################################

user_domain($1)

######################################
# Allow httpd_admin_t to edit the server config files
######################################
allow $1_t httpd_config_t:file create_file_perms;
allow $1_t httpd_config_t:dir rw_dir_perms;
allow $1_t httpd_config_t:lnk_file link_file_perms;
allow $1_t httpd_config_t:security { sid_to_context };

######################################################
# Allow the httpd_admin_t to view or edit the web server log files
#######################################################
allow $1_t httpd_log_files_t:file create_file_perms;
allow $1_t httpd_log_files_t:dir rw_dir_perms ;
allow $1_t httpd_log_files_t:security { sid_to_context };
allow $1_t httpd_log_files_t:lnk_file link_file_perms;

##################################################
# Allow the httpd_admin_t to view files in /etc/httpd/modules
# directory.  This is where the module libraries for 
# Apache are kept
##################################################
allow $1_t httpd_modules_t:dir r_dir_perms;
allow $1_t httpd_modules_t:file r_file_perms;

####################################################
# Allow the httpd_admin_t to do the following to httpd
# executable and process if you want the httpd admin role to run the binary
#######################################################
#allow $1_t httpd_exec_t:file rx_file_perms;
#allow $1_t httpd_t:security { sid_to_context };
#allow $1_t httpd_t:process{ sigkill sigstop signal transition};

###########################################################################
# Allow the httpd admin to edit or create content, scripts, and 
# htaccess files
##########################################################################
allow $1_t httpd_sys_content_t:file create_file_perms;
allow $1_t httpd_user_content_t:file create_file_perms;
allow $1_t httpd_sys_content_t:dir rw_dir_perms;
allow $1_t httpd_user_content_t:dir rw_dir_perms;
allow $1_t httpd_sys_content_t:lnk_file {create};
allow $1_t httpd_user_content_t:lnk_file {create};

allow $1_t httpd_sys_script_t:file create_file_perms;
allow $1_t httpd_sys_script_t:dir create_dir_perms;
allow $1_t httpd_sys_script_t:lnk_file {create};

allow $1_t httpd_sys_htaccess_t:file create_file_perms;
allow $1_t httpd_sys_htaccess_t:lnk_file {create};

allow $1_t httpd_sys_script_r_t:file create_file_perms;
allow $1_t httpd_sys_script_r_t:lnk_file {create};
allow $1_t httpd_sys_script_r_t:dir create_dir_perms;

allow $1_t httpd_user_script_r_t:file create_file_perms;
allow $1_t httpd_user_script_r_t:lnk_file {create};
allow $1_t httpd_user_script_r_t:dir create_dir_perms;

allow $1_t httpd_sys_script_rw_t:file rw_file_perms;
allow $1_t httpd_sys_script_rw_t:lnk_file {create};
allow $1_t httpd_sys_script_rw_t:dir rw_dir_perms;

allow $1_t httpd_user_script_rw_t:file rw_file_perms;
allow $1_t httpd_user_script_rw_t:lnk_file {create};
allow $1_t httpd_user_script_rw_t:dir rw_dir_perms;

allow $1_t httpd_sys_script_a_t:file ra_file_perms;
allow $1_t httpd_sys_script_a_t:lnk_file {create};
allow $1_t httpd_sys_script_a_t:dir ra_dir_perms;

allow $1_t httpd_user_script_a_t:file ra_file_perms;
allow $1_t httpd_user_script_a_t:lnk_file {create};
allow $1_t httpd_user_script_a_t:dir ra_dir_perms;

####################################
# Allow a domain change to httpd_admin_t via the newrole command
#####################################
allow $1_t newrole_t:fd use;
allow $1_t newrole_t:process {sigchld};
can_exec($1_t, shell_exec_t)
allow $1_t shell_exec_t:file {entrypoint};
allow newrole_t $1_t:process {transition};

#############################################################################
# Allow the httpd admin to use chcon to change contexts  on scripts, web pages,
# and htaccess files. 
###########################################################################
allow $1_t httpd_sys_script_t:dir  {relabelto};
allow $1_t httpd_sys_script_a_t:dir  {relabelto};
allow $1_t httpd_sys_script_r_t:dir  {relabelto};
allow $1_t httpd_sys_script_rw_t:dir  {relabelto};

allow $1_t httpd_user_script_t:dir  {relabelto};
allow $1_t httpd_user_script_a_t:dir  {relabelto};
allow $1_t httpd_user_script_r_t:dir  {relabelto};
allow $1_t httpd_user_script_rw_t:dir  {relabelto};

allow $1_t httpd_sys_script_a_t:file  {relabelto};
allow $1_t httpd_sys_script_r_t:file  {relabelto};
allow $1_t httpd_sys_script_rw_t:file  {relabelto};

allow $1_t httpd_user_script_r_t:file  {relabelto};
allow $1_t httpd_user_script_rw_t:file  {relabelto};
allow $1_t httpd_user_script_a_t:file  {relabelto};

allow $1_t httpd_sys_content_t:dir {relabelto};
allow $1_t httpd_user_content_t:dir {relabelto};

allow $1_t httpd_sys_content_t:file {relabelto};
allow $1_t httpd_sys_htaccess_t:file {relabelto};
allow $1_t httpd_user_content_t:file {relabelto};
allow $1_t httpd_user_htaccess_t:file {relabelto};

')


# httpd_admin_t has access to all of the httpd files, such as
# the configuration files and the log files.  They also 
# have access to system content and/or user content
#
type httpd_admin_t, domain;
role httpd_admin_r types httpd_admin_t;
every_domain(httpd_admin_t)

httpd_admin_domain(httpd_admin)

')
#DESC User - Domains for ordinary users.
#
#################################
#full_user_role(java)
#allow system_r java_r;
#allow sysadm_r java_r;

full_user_role(user)
# a role for staff that allows seeing all domains and control over the user_t
# domain
#full_user_role(staff)
#allow staff_t user_t:process signal_perms;
#r_dir_file(staff_t, domain)
#file_type_auto_trans(staff_t, user_home_dir_t, user_home_t)

# read localization information
allow user_t locale_t:dir r_dir_perms;
allow user_t locale_t:{file lnk_file} r_file_perms;

# if adding new user roles make sure you edit the in_user_role macro in
# macros/user_macros.te to match

# lots of user programs accidentally search /root, and also the admin often
# logs in as UID=0 domain=user_t...
dontaudit unpriv_userdomain sysadm_home_dir_t:dir { getattr search };

# system_r is authorized for user_t as a fallback for unmodified daemons.
role system_r types user_t;

# change from role $1_r to $2_r and relabel tty appropriately
define(`role_tty_type_change', `
allow $1_r $2_r;
type_change $2_t $1_devpts_t:chr_file $2_devpts_t;
type_change $2_t $1_tty_device_t:chr_file $2_tty_device_t;
')

ifdef(`newrole.te', `
#
# Allow the user roles to transition
# into each other.
role_tty_type_change(sysadm, user)
role_tty_type_change(user, sysadm)
#role_tty_type_change(staff, sysadm)
#role_tty_type_change(sysadm, staff)
')

# "ps aux" and "ls -l /dev/pts" make too much noise without this
dontaudit unpriv_userdomain ptyfile:chr_file getattr;



full_user_role(cougaar)
allow system_r cougaar_r;
allow sysadm_r cougaar_r;
allow user_r cougaar_r;

allow user_t var_log_t:dir { getattr read };
allow user_t var_spool_t:file { execute };
allow user_t sysadm_home_dir_t:dir { add_name read remove_name write };
allow user_t sysadm_home_dir_t:file { create getattr link read unlink write };
allow user_t user_t:capability { sys_tty_config kill };

# added to run society with acme
allow user_t sysadm_home_dir_t:file { setattr };
allow user_xauth_t sshd_t:unix_stream_socket { read write };
allow user_xauth_t sysadm_home_dir_t:dir { add_name remove_name search write };
allow user_xauth_t sysadm_home_dir_t:file { create getattr link read unlink write };


#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

#################################
#
# Rules for the kernel_t domain.
#

#
# kernel_t is the domain of kernel threads.
# It is also the target type when checking permissions in the system class.
# 
type kernel_t, domain;
role system_r types kernel_t;
general_domain_access(kernel_t)
general_proc_read_access(kernel_t)
base_file_read_access(kernel_t)
uses_shlib(kernel_t)

# Use capabilities.
allow kernel_t self:capability *;

# Run init in the init_t domain.
domain_auto_trans_read(kernel_t, init_exec_t, init_t)

# Share state with the init process.
allow kernel_t init_t:process share;

# Mount and unmount file systems.
allow kernel_t fs_type:filesystem mount_fs_perms;

# Search the persistent label mapping.
allow kernel_t file_labels_t:dir search;

# Send signal to any process.
allow kernel_t domain:process signal;

# Access the console.
allow kernel_t device_t:dir search;
allow kernel_t console_device_t:chr_file rw_file_perms;

# Access the initrd filesystem.
allow kernel_t file_t:chr_file rw_file_perms;
can_exec(kernel_t, file_t)
ifdef(`chroot.te', `
can_exec(kernel_t, chroot_exec_t)
')
allow kernel_t self:capability sys_chroot;

allow kernel_t file_t:dir mounton;
allow kernel_t file_t:dir rw_dir_perms;
allow kernel_t file_t:blk_file create_file_perms;
allow kernel_t { sysctl_t sysctl_kernel_t }:file { setattr rw_file_perms };

# Lookup the policy.
allow kernel_t policy_config_t:dir r_dir_perms;

# Reload the policy from the real root.
allow kernel_t security_t:security load_policy;

ifdef(`modutil.te', `
# Run insmod (for kernel module loader).
domain_auto_trans_read(kernel_t,insmod_exec_t,insmod_t)
allow kernel_t insmod_exec_t:lnk_file read;
')

# /proc/sys/kernel/modprobe is set to /bin/true if not using modules.
can_exec(kernel_t, bin_t)

# added to run society with acme 
allow kernel_t mount_t:udp_socket { write };

#################################
#
# Rules for the acme_t domain.
#
# acme_t is the domain for the ruby and acme env of cougaar .
# ping_exec_t is the type of the corresponding program.
#
type acme_t, domain;
role sysadm_r types acme_t;
role system_r types acme_t;
every_domain(acme_t)
type acme_exec_t, file_type, exec_type;

# Transition into this domain when you run this program.
domain_auto_trans(sysadm_t, acme_exec_t, acme_t)
domain_auto_trans(initrc_t, acme_exec_t, acme_t)
domain_auto_trans(cougaar_t, acme_exec_t, acme_t)

# Let acme create raw socket.
allow acme_t self:tcp_socket { create bind setopt getopt write read };
allow acme_t any_socket_t:tcp_socket sendto;

# Let  acme receive ICMP replies.
allow acme_t { self tcp_socket_t }:tcp_socket recvfrom;

# Use capabilities.
allow acme_t acme_t:capability { net_raw setuid };

#allow role cougaar_r types acme_t;

# added to run society under acme
allow acme_t acme_exec_t:file { execute_no_trans };
allow acme_t acme_t:capability { net_bind_service setgid };
allow acme_t acme_t:tcp_socket { acceptfrom connectto };
allow acme_t bin_t:file { execute execute_no_trans };
allow acme_t crond_t:dir { search };
allow acme_t crond_t:file { getattr read };
allow acme_t devlog_t:sock_file { write };
allow acme_t dhcpc_t:dir { search };
allow acme_t dhcpc_t:file { getattr read };
allow acme_t file_t:dir { getattr search };
allow acme_t getty_t:dir { search };
allow acme_t getty_t:file { getattr read };
allow acme_t init_t:dir { search };
allow acme_t init_t:file { getattr read };
allow acme_t initrc_tmp_t:dir { getattr };
allow acme_t initrc_tmp_t:file { getattr };
allow acme_t initrc_t:dir { search };
allow acme_t initrc_t:file { getattr read };
allow acme_t initrc_t:udp_socket { recvfrom };
allow acme_t initrc_var_run_t:file { write };
allow acme_t kernel_t:dir { search };
allow acme_t kernel_t:file { getattr read };
allow acme_t klogd_t:dir { search };
allow acme_t klogd_t:file { getattr read };
allow acme_t lib_t:file { execute };
allow acme_t mount_t:dir { search };
allow acme_t mount_t:file { getattr read };
allow acme_t newrole_t:dir { search };
allow acme_t newrole_t:file { getattr read };
allow acme_t nfs_t:dir { add_name create getattr read remove_name search write };
allow acme_t nfs_t:file { append create getattr ioctl link lock read rename setattr unlink write };
allow acme_t nfs_t:lnk_file { getattr read };
allow acme_t shell_exec_t:file { execute execute_no_trans };
allow acme_t sshd_tmp_t:dir { getattr };
allow acme_t sshd_t:dir { search };
allow acme_t sshd_t:file { getattr read };
allow acme_t su_exec_t:file { execute execute_no_trans };
allow acme_t sysadm_home_dir_t:dir { add_name getattr remove_name search write };
allow acme_t sysadm_home_dir_t:file { create getattr link read unlink write };
allow acme_t sysadm_home_t:dir { search };
allow acme_t sysadm_home_t:file { getattr ioctl read };
allow acme_t sysadm_t:dir { search };
allow acme_t sysadm_t:file { getattr read };
allow acme_t syslogd_t:dir { search };
allow acme_t syslogd_t:file { getattr read };
allow acme_t syslogd_t:unix_dgram_socket { sendto };
allow acme_t tmp_t:dir { add_name remove_name write };
allow acme_t tmp_t:file { append create rename setattr unlink write };
allow acme_t user_t:dir { search };
allow acme_t user_t:file { getattr read };
allow acme_t usr_t:file { append setattr write };
allow acme_t var_spool_t:file { execute };
allow acme_t xauth_exec_t:file { execute execute_no_trans };
allow acme_t acme_t:tcp_socket { acceptfrom connectto };
allow acme_t devlog_t:sock_file { write };
allow acme_t file_t:dir { getattr search };
allow acme_t initrc_tmp_t:dir { getattr };
allow acme_t initrc_tmp_t:file { getattr };
allow acme_t initrc_t:udp_socket { recvfrom };
allow acme_t lib_t:file { execute };
allow acme_t nfs_t:dir { add_name create getattr read remove_name search write };
allow acme_t nfs_t:file { append getattr ioctl link lock read rename setattr unlink write };
allow acme_t nfs_t:lnk_file { getattr read };
allow acme_t sshd_tmp_t:dir { getattr };
allow acme_t tmp_t:dir { add_name remove_name write };
allow acme_t tmp_t:file { create rename setattr unlink write };
allow acme_t usr_t:file { append };
allow acme_t system_crond_t:dir { search };
allow acme_t system_crond_t:file { getattr read };
allow acme_t acme_t:capability { kill };
allow acme_t crond_t:dir { getattr };
allow acme_t dhcpc_t:dir { getattr };
allow acme_t getty_t:dir { getattr };
allow acme_t init_t:dir { getattr };
allow acme_t initrc_t:dir { getattr };
allow acme_t kernel_t:dir { getattr };
allow acme_t klogd_t:dir { getattr };
allow acme_t mount_t:dir { getattr };
allow acme_t newrole_t:dir { getattr };
allow acme_t sshd_t:dir { getattr };
allow acme_t sysadm_t:dir { getattr };
allow acme_t syslogd_t:dir { getattr };
allow acme_t user_t:dir { getattr };
allow acme_t usr_t:dir { add_name write };
allow acme_t usr_t:file { create };








#DESC Checkpolicy - SELinux policy compliler
#
# Authors:  Frank Mayer, mayerf@tresys.com
#

###########################
# 
# checkpolicy_t is the domain type for checkpolicy
# checkpolicy_exec_t if file type for the executable

type checkpolicy_t, domain;
role sysadm_r types checkpolicy_t;

type checkpolicy_exec_t, file_type, exec_type, sysadmfile;

##########################
# 
# Rules

domain_auto_trans(sysadm_t, checkpolicy_exec_t, checkpolicy_t)

# able to create and modify binary policy files
allow checkpolicy_t policy_config_t:dir rw_dir_perms;
allow checkpolicy_t policy_config_t:notdevfile_class_set create_file_perms;

###########################
# constrain what checkpolicy can use as source files
#

# only allow read of policy source files
allow checkpolicy_t policy_src_t:dir r_dir_perms;
allow checkpolicy_t policy_src_t:notdevfile_class_set r_file_perms;

# allow test policies to be created in src directories
file_type_auto_trans(checkpolicy_t, policy_src_t, policy_config_t)

# directory search permissions for path to source and binary policy files
allow checkpolicy_t root_t:dir search;
allow checkpolicy_t etc_t:dir search;

# Read the devpts root directory.  
allow checkpolicy_t devpts_t:dir r_dir_perms;
ifdef(`sshd.te',
`allow checkpolicy_t sshd_devpts_t:dir r_dir_perms;')

# Other access
allow checkpolicy_t admin_tty_type:chr_file { read write ioctl getattr };
uses_shlib(checkpolicy_t)
allow checkpolicy_t self:capability dac_override;

allow checkpolicy_t sysadm_tmp_t:file { getattr write } ;

##########################
# Allow users to execute checkpolicy without a domain transition
# so it can be used without privilege to write real binary policy file
can_exec(user_t, checkpolicy_exec_t)

allow checkpolicy_t privfd:fd use;

# Added to run society under acme 
allow checkpolicy_t sysadm_home_t:dir { search };
allow checkpolicy_t sysadm_home_t:file { getattr ioctl read setattr write };



#DESC Chkpwd - PAM password checking programs
#
# Domains for the /sbin/.*_chkpwd utilities.
#

#
# chkpwd_exec_t is the type of the /sbin/.*_chkpwd executables.
#
type chkpwd_exec_t, file_type, sysadmfile, exec_type;

# Everything else is in the chkpwd_domain macro in
# macros/program/chkpwd_macros.te.
#DESC Cougaar
#
# File: cougaar.te
# Author(s):
#

role cougaar_r types cougaar_t;
#every_domain(cougaar_t)
#uses_java(cougaar_t);
#type cougaar_exec_t 
#allow cougaar_r:{file lnk_file} { create ioctl read getattr lock write setattr append };
allow cougaar_t cougaar_t:dir { create rmdir add_name remove_name write};
allow cougaar_t cougaar_t:file { append execute_no_trans rename setattr };
allow cougaar_t file_t:dir { search };
allow cougaar_t fs_t:filesystem { associate };
#allow cougaar_t sysadm_tty_device_t:chr_file { getattr };
allow cougaar_t tmp_t:file { setattr unlink write };
allow cougaar_t tty_device_t:chr_file { getattr };
allow cougaar_t user_devpts_t:chr_file { ioctl };
allow cougaar_t user_home_dir_t:dir { remove_name };
allow cougaar_t user_home_dir_t:file { read rename unlink write };
allow cougaar_t user_home_t:dir { add_name getattr read remove_name write };
allow cougaar_t user_home_t:file { append create getattr unlink write };
allow cougaar_t cougaar_t:dir { add_name remove_name write };
allow cougaar_t cougaar_t:file { create execute unlink write };
allow cougaar_t initrc_var_run_t:file { lock };
allow cougaar_t locale_t:dir { search };
allow cougaar_t locale_t:file { getattr read };
allow cougaar_t random_device_t:chr_file { getattr read };
allow cougaar_t resolv_conf_t:file { getattr read };
allow cougaar_t sysctl_kernel_t:dir { search };
allow cougaar_t sysctl_kernel_t:file { read };
allow cougaar_t user_devpts_t:chr_file { read write };
allow cougaar_t user_home_dir_t:dir { add_name getattr read search write };
allow cougaar_t user_home_dir_t:file { create getattr setattr };
allow cougaar_t user_home_t:dir { search };
allow cougaar_t user_home_t:file { read };
allow cougaar_t var_spool_t:file { execute };
allow cougaar_t var_yp_t:dir { search };
allow cougaar_t var_yp_t:file { read };

allow cougaar_t acme_t:process { sigkill };
allow cougaar_t nfs_t:dir { getattr read search };
allow cougaar_t nfs_t:file { getattr ioctl read };
allow cougaar_t nfs_t:lnk_file { read };
allow cougaar_xauth_t nfs_t:dir { add_name remove_name search write };
allow cougaar_xauth_t nfs_t:file { create getattr link read unlink write };
allow cougaar_xauth_t sshd_t:unix_stream_socket { read write };









#DESC Crond - Crond daemon
#
# Domains for the top-level crond daemon process and
# for system cron jobs.  The domains for user cron jobs
# are in macros/program/crond_macros.te.
#

#
# Authors:  Jonathan Crowley (MITRE) <jonathan@mitre.org>,
#	    Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser
#
# Domain for crond.  It needs auth to check for locked accounts.

daemon_domain(crond, `, privrole, privmail, auth, privfd')

# This domain is granted permissions common to most domains (including can_net)
general_domain_access(crond_t)

# Type for the anacron executable.
type anacron_exec_t, file_type, sysadmfile, exec_type;

# Type for temporary files.
tmp_domain(crond)

# Domain for system cron jobs.
type system_crond_t, domain, privlog, privmail;

# Read and write console and ttys.
allow system_crond_t devtty_t:chr_file rw_file_perms;

# Read system information files in /proc.
allow system_crond_t proc_t:dir r_dir_perms;
allow system_crond_t proc_t:file r_file_perms;

ifdef(`mta.te', `
allow mta_user_agent system_crond_t:fd use;
')

# to stop killall type operations from filling our logs
dontaudit system_crond_t domain:dir search;

# read files in /etc (anacrontab)  execute /etc/cron.hourly/*, etc.
allow system_crond_t etc_t:file read;
allow system_crond_t etc_runtime_t:file read;

# read localization information
allow crond_t locale_t:dir r_dir_perms;
allow crond_t locale_t:{file lnk_file} r_file_perms;
allow system_crond_t locale_t:dir r_dir_perms;
allow system_crond_t locale_t:{file lnk_file} r_file_perms;

# Type for log files.
type cron_log_t, file_type, sysadmfile, logfile;
# Use this type when creating files in /var/log.
file_type_auto_trans(crond_t, var_log_t, cron_log_t)

# Use capabilities.
allow crond_t crond_t:capability { setgid setuid net_bind_service };

# Check entrypoint permission on crontab files.
allow crond_t security_t:security compute_av;

# for finding binaries and /bin/sh
allow crond_t { bin_t sbin_t }:dir search;
allow crond_t bin_t:lnk_file read;

# Read from /var/spool/cron.
allow crond_t var_lib_t:dir search;
allow crond_t var_spool_t:dir r_dir_perms;
allow crond_t cron_spool_t:dir r_dir_perms;
allow crond_t cron_spool_t:file r_file_perms;

# Read system crontabs
allow crond_t system_crond_script_t:file r_file_perms;
allow crond_t system_crond_script_t:dir r_dir_perms;

# Read /etc/security/default_contexts.
allow crond_t default_context_t:file r_file_perms;

allow crond_t etc_t:file { getattr read };
allow crond_t etc_t:lnk_file read;

# crond tries to search /root.  Not sure why.
allow crond_t sysadm_home_dir_t:dir r_dir_perms;

# to search /home
allow crond_t home_root_t:dir { getattr search };
allow crond_t user_home_dir_type:dir r_dir_perms;

# Run a shell.
can_exec(crond_t, shell_exec_t)

ifdef(`rpm.te',
`# Run the rpm program in the rpm_t domain. Allow creation of RPM log files
# via redirection of standard out.
domain_auto_trans(crond_t, rpm_exec_t, rpm_t)
allow crond_t var_log_rpm_t: file create_file_perms;

domain_auto_trans(system_crond_t, rpm_exec_t, rpm_t)
allow system_crond_t var_log_rpm_t: file create_file_perms;')

# This system_r role is authorized for this domain.
role system_r types system_crond_t;

uses_shlib(system_crond_t);
general_domain_access(system_crond_t);
allow system_crond_t var_log_t:file r_file_perms;

# Type for system crontab files.
type system_crond_script_t, file_type, sysadmfile;

# Permit crond_t to transition to this domain.
# The transition is requested explicitly by the modified crond 
# via execve_secure.  There is no way to set up an automatic
# transition, since crontabs are configuration files, not executables.
domain_trans(crond_t, shell_exec_t, system_crond_t)

# Transition to this domain for anacron as well.
# Still need to study anacron.
domain_auto_trans(initrc_t, anacron_exec_t, system_crond_t)

# Access log files
file_type_auto_trans(system_crond_t, var_log_t, cron_log_t)

# Inherit and use descriptors from init.
allow system_crond_t init_t:fd use;

# Inherit and use descriptors from initrc.
allow system_crond_t initrc_t:fd use;

# Write to a socket from initrc.
allow system_crond_t initrc_t:udp_socket rw_socket_perms;

# Use capabilities.
allow system_crond_t system_crond_t:capability { setgid setuid dac_override fowner net_bind_service fsetid };

# Read the system crontabs.
allow system_crond_t system_crond_script_t:file r_file_perms;

# 
# Since crontab files are not directly executed,
# crond must ensure that the crontab file has
# a type that is appropriate for the domain of
# the system cron job.  It performs an entrypoint
# permission check for this purpose.
#
allow system_crond_t system_crond_script_t:file entrypoint;
ifdef(`fcron.te', `
allow system_crond_t sysadm_cron_spool_t:file entrypoint;
')

# Run helper programs in the system_crond_t domain.
allow system_crond_t { bin_t sbin_t }:dir r_dir_perms;
allow system_crond_t { bin_t sbin_t }:lnk_file read;
can_exec(system_crond_t, etc_t)
can_exec(system_crond_t, bin_t)
can_exec(system_crond_t, sbin_t)
can_exec(system_crond_t, exec_type)


# Read from /var/spool/cron.
allow system_crond_t cron_spool_t:dir r_dir_perms;
allow system_crond_t cron_spool_t:file r_file_perms;

# Write to /var/lib/slocate.db.
allow system_crond_t var_lib_t:dir rw_dir_perms;
allow system_crond_t var_lib_t:file create_file_perms;

# Update whatis files.
allow system_crond_t catman_t:dir rw_dir_perms;
allow system_crond_t catman_t:file create_file_perms;

# Write /var/lock/makewhatis.lock.
allow system_crond_t var_lock_t:dir rw_dir_perms;
allow system_crond_t var_lock_t:file create_file_perms;

# Modutils are now combined, so we can no longer distinguish them.
# Let crond run the insmod executable in the insmod_t domain.
ifdef(`modutil.te', `
system_crond_entry(insmod_exec_t, insmod_t)
')

# for if /var/mail is a symlink
allow crond_t mail_spool_t:lnk_file read;

# Run logrotate in the logrotate_t domain.
ifdef(`logrotate.te', `
system_crond_entry(logrotate_exec_t, logrotate_t)
')

ifdef(`mta.te', `
r_dir_file(system_mail_t, crond_tmp_t)
')

# Stat any file and search any directory for find.
allow system_crond_t file_type:file_class_set getattr;
allow system_crond_t file_type:dir { read search getattr };

# Create temporary files.
type system_crond_tmp_t, file_type, sysadmfile, tmpfile;
file_type_auto_trans(system_crond_t, { tmp_t crond_tmp_t }, system_crond_tmp_t)

# /sbin/runlevel ask for w access to utmp, but will operate
# correctly without it.  Do not audit write denials to utmp.
dontaudit system_crond_t initrc_var_run_t:file { read write };

# Access accounting summary files.
allow system_crond_t var_log_sa_t:file create_file_perms;
allow system_crond_t var_log_sa_t:dir rw_dir_perms;

# Access other spool directories like
# /var/spool/anacron and /var/spool/slrnpull.
allow system_crond_t var_spool_t:file create_file_perms;
allow system_crond_t var_spool_t:dir rw_dir_perms;

# Do not audit attempts to search unlabeled directories (e.g. slocate).
dontaudit system_crond_t unlabeled_t:dir r_dir_perms;
dontaudit system_crond_t unlabeled_t:file r_file_perms;

# Determine the set of legal user SIDs that can be reached.
allow crond_t security_t:security { sid_to_context context_to_sid get_user_sids };


# please verify later time added to make it work in enforcement mode Mike 
allow crond_t any_socket_t:udp_socket { sendto };
allow crond_t crond_t:tcp_socket { bind connect create read write };
allow crond_t crond_t:udp_socket { bind create read setopt write };
allow crond_t netif_eth0_t:netif { tcp_send udp_send };
allow crond_t netmsg_eth0_t:tcp_socket { connectto recvfrom };
allow crond_t netmsg_eth0_t:udp_socket { recvfrom };
allow crond_t node_t:node { tcp_send udp_send };
allow crond_t port_t:tcp_socket { name_bind };
allow crond_t port_t:udp_socket { name_bind };
allow crond_t var_yp_t:dir { search };
allow crond_t var_yp_t:file { read };
allow system_crond_t devpts_t:dir { getattr };
allow system_crond_t devpts_t:filesystem { getattr };
allow system_crond_t etc_t:lnk_file { read };
allow system_crond_t fs_t:filesystem { getattr };
allow system_crond_t initrc_var_run_t:file { lock };
allow system_crond_t lib_t:file { execute execute_no_trans ioctl read };
allow system_crond_t proc_t:filesystem { getattr };
allow system_crond_t proc_t:lnk_file { read };
allow system_crond_t sysctl_kernel_t:dir { search };
allow system_crond_t sysctl_kernel_t:file { getattr read };
allow system_crond_t sysctl_t:dir { search };
allow system_crond_t sysctl_t:file { getattr read };
allow system_crond_t usr_t:file { read };
allow crond_t var_spool_t:file { execute getattr read };
allow system_crond_t nfs_t:dir { getattr };








#DESC Crontab - Crontab manipulation programs
#
# Domains for the crontab program.
#

# Type for the crontab executable.
type crontab_exec_t, file_type, sysadmfile, exec_type;

# Everything else is in the crontab_domain macro in
# macros/program/crontab_macros.te.
#DESC DHCPC - DHCP client
#
# Authors:  Wayne Salamon (NAI Labs) <wsalamon@tislabs.com>
#

#################################
#
# Rules for the dhcpc_t domain.
#
# dhcpc_t is the domain for the client side of DHCP. dhcpcd, the DHCP 
# network configurator daemon started by /etc/sysconfig/network-scripts 
# rc scripts, runs in this domain.
# dhcpc_exec_t is the type of the dhcpcd executable.
# The dhcpc_t can be used for other DHCPC related files as well.
#
type dhcpc_t, domain, privlog;
role system_r types dhcpc_t;
every_domain(dhcpc_t)
type dhcpc_exec_t, file_type, sysadmfile, exec_type;
domain_auto_trans(initrc_t, dhcpc_exec_t, dhcpc_t)

ifdef(`cardmgr.te', `
domain_auto_trans(cardmgr_t, dhcpc_exec_t, dhcpc_t)
allow cardmgr_t dhcpc_t:process signal_perms;
')

# for the dhcp client to run ping to check IP addresses
ifdef(`ping.te', `
domain_auto_trans(dhcpc_t, ping_exec_t, ping_t)
# because dhcpc is buggy and leaves file handles open...
dontaudit ping_t dhcpc_state_t:file read;
dontaudit ping_t dhcpc_t:packet_socket { read write };
dontaudit ping_t dhcpc_t:udp_socket { read write };
')

# Type for files created during execution of dhcpcd.
type var_run_dhcpc_t, file_type, sysadmfile, pidfile;
ifdef(`dhcpd.te', `',
`type dhcp_state_t, file_type, sysadmfile;')
type dhcpc_state_t, file_type, sysadmfile;
type etc_dhcpc_t, file_type, sysadmfile;
file_type_auto_trans(dhcpc_t, var_run_t, var_run_dhcpc_t)

# Inherit and use descriptors from init.
allow dhcpc_t init_t:fd use;

# Use capabilities
allow dhcpc_t self:capability { net_admin net_raw net_bind_service };

# Allow read/write to /etc/resolv.conf. Note that any files in /etc 
# created by dhcpcd will be labelled resolv_conf_t. As of RH 7.2, no
# other files are accessed in the /etc dir, only in /etc/dhcpc dir.
file_type_auto_trans(dhcpc_t, etc_t, resolv_conf_t)

# Allow access to the dhcpc file types
allow dhcpc_t etc_dhcpc_t:file rw_file_perms;
allow dhcpc_t etc_dhcpc_t:dir rw_dir_perms;
can_exec(dhcpc_t, { dhcpc_exec_t etc_dhcpc_t sbin_t })
domain_auto_trans(dhcpc_t, ifconfig_exec_t, ifconfig_t)
# because dhclient is buggy and does not close file handles
dontaudit ifconfig_t dhcpc_t:{ packet_socket udp_socket } { read write };
dontaudit ifconfig_t dhcpc_state_t:file { read write };

# Allow dhcpc_t to use packet sockets
allow dhcpc_t self:packet_socket create_socket_perms;
allow dhcpc_t self:packet_socket recvfrom;
allow dhcpc_t netmsg_eth0_t:packet_socket { recvfrom };
allow dhcpc_t icmp_socket_t:packet_socket { recvfrom };
file_type_auto_trans(dhcpc_t, dhcp_state_t, dhcpc_state_t)

can_exec(dhcpc_t, { bin_t shell_exec_t })
# need to modify later  
allow dhcpc_t crond_t:packet_socket { recvfrom };
allow dhcpc_t sysadm_t:packet_socket { recvfrom };
allow dhcpc_t tcp_socket_t:packet_socket { recvfrom };
allow dhcpc_t user_t:packet_socket { recvfrom };
allow dhcpc_t cougaar_t:packet_socket { recvfrom };
allow dhcpc_t initrc_t:packet_socket { recvfrom };
allow dhcpc_t sshd_t:packet_socket { recvfrom };
allow dhcpc_t mount_t:packet_socket { recvfrom };
allow dhcpc_t newrole_t:packet_socket { recvfrom };
allow dhcpc_t initrc_exec_t:file { execute };
allow dhcpc_t local_login_t:packet_socket { recvfrom };
allow dhcpc_t syslogd_t:packet_socket { recvfrom };
allow dhcpc_t var_spool_t:file { execute };

allow dhcpc_t dhcpc_t:capability { sys_admin };

# added to run society under acme
allow dhcpc_t acme_t:packet_socket { recvfrom };
allow dhcpc_t sysadm_su_t:packet_socket { recvfrom };


#DESC Fsadm - Disk and file system administration
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

#################################
#
# Rules for the fsadm_t domain.
#
# fsadm_t is the domain for disk and file system
# administration.
# fsadm_exec_t is the type of the corresponding programs.
#
type fsadm_t, domain, privlog;
role system_r types fsadm_t;
role sysadm_r types fsadm_t;

general_domain_access(fsadm_t)

# Read system information files in /proc.
allow fsadm_t proc_t:dir r_dir_perms;
allow fsadm_t proc_t:notdevfile_class_set r_file_perms;

# Read system variables in /proc/sys
allow fsadm_t sysctl_kernel_t:file r_file_perms;
allow fsadm_t sysctl_kernel_t:dir r_dir_perms;

base_file_read_access(fsadm_t)

# Read /etc.
allow fsadm_t etc_t:dir r_dir_perms;
allow fsadm_t etc_t:notdevfile_class_set r_file_perms;

# Read module-related files.
allow fsadm_t modules_conf_t:{ file lnk_file } r_file_perms;

# Read /dev directories and any symbolic links.
allow fsadm_t device_t:dir r_dir_perms;
allow fsadm_t device_t:lnk_file r_file_perms;

uses_shlib(fsadm_t)

type fsadm_exec_t, file_type, sysadmfile, exec_type;
domain_auto_trans(initrc_t, fsadm_exec_t, fsadm_t)
domain_auto_trans(sysadm_t, fsadm_exec_t, fsadm_t)

type fsadm_tmp_t, file_type, sysadmfile, tmpfile;
file_type_auto_trans(fsadm_t, tmp_t, fsadm_tmp_t)

# remount file system to apply changes
allow fsadm_t fs_t:filesystem remount;

# Use capabilities.  ipc_lock is for losetup
allow fsadm_t self:capability { ipc_lock sys_rawio sys_admin };

# Write to /etc/mtab.
file_type_auto_trans(fsadm_t, etc_t, etc_runtime_t, file)

# Inherit and use descriptors from init.
allow fsadm_t init_t:fd use;

# Run other fs admin programs in the fsadm_t domain.
can_exec(fsadm_t, fsadm_exec_t)

# Access disk devices.
allow fsadm_t fixed_disk_device_t:devfile_class_set rw_file_perms;
allow fsadm_t removable_device_t:devfile_class_set rw_file_perms;

# Access lost+found.
allow fsadm_t lost_found_t:dir create_dir_perms;
allow fsadm_t lost_found_t:notdevfile_class_set create_file_perms;

# Recreate /mnt/cdrom. 
allow fsadm_t file_t:dir { search read getattr rmdir create };

# Recreate /dev/cdrom.
allow fsadm_t device_t:dir rw_dir_perms;
allow fsadm_t device_t:lnk_file { unlink create };

# Enable swapping to devices and files
allow fsadm_t swapfile_t:file { getattr swapon };
allow fsadm_t fixed_disk_device_t:blk_file { getattr swapon };

# XXX Why does updfstab run insmod?
domain_auto_trans(fsadm_t, insmod_exec_t, insmod_t)

# Allow console log change (updfstab)
allow fsadm_t kernel_t:system syslog_console;

# Access terminals.
allow fsadm_t admin_tty_type:chr_file rw_file_perms;
ifdef(`gnome-pty-helper.te', `allow fsadm_t sysadm_gph_t:fd use;')

# read localization information
allow fsadm_t locale_t:dir r_dir_perms;
allow fsadm_t locale_t:{file lnk_file} r_file_perms;

# Added by us
allow fsadm_t insmod_exec_t:file { read };
allow fsadm_t insmod_exec_t:lnk_file { read };

#DESC Getty - Manage ttys
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

#################################
#
# Rules for the getty_t domain.
#
daemon_domain(getty, `, mlstrustedwriter, privfd')

type etc_getty_t, file_type, sysadmfile;
r_dir_file(getty_t, etc_getty_t)

allow getty_t console_device_t:chr_file setattr;

tmp_domain(getty)
log_domain(getty)

allow getty_t { etc_t etc_runtime_t }:file { getattr read };
allow getty_t etc_t:lnk_file read;
allow getty_t self:process { getpgid getsession };
allow getty_t self:unix_dgram_socket create_socket_perms;
allow getty_t self:unix_stream_socket create_socket_perms;

# for ldap and other authentication services
allow getty_t resolv_conf_t:file { getattr read };

# to allow w to display everyone...
#allow userdomain ttyfile:chr_file getattr;

# Use capabilities.
allow getty_t getty_t:capability { dac_override chown sys_tty_config };

# fbgetty needs fsetid for some reason
allow getty_t getty_t:capability fsetid;

# Run getty in its own domain.
domain_auto_trans(init_t, getty_exec_t, getty_t)

# Inherit and use descriptors from init.
allow getty_t init_t:fd use;

# Run login in local_login_t domain.
allow getty_t bin_t:dir search;
domain_auto_trans_read(getty_t, login_exec_t, local_login_t)

# Write to /var/run/utmp.
allow getty_t initrc_var_run_t:file rw_file_perms;

# Write to /var/log/wtmp.
allow getty_t wtmp_t:file rw_file_perms;

# Chown, chmod, read and write ttys.
allow getty_t tty_device_t:chr_file { setattr rw_file_perms };
allow getty_t ttyfile:chr_file { setattr rw_file_perms };


rw_dir_create_file(getty_t, var_lock_t)
#DESC Groupadd - Manage system groups
#
# Authors:  David Caplan, dac@tresys.com
#	    (Based on useradd.te by Chris Vance <cvance@tislabs.com>)
#

#################################
#
# Rules for the groupadd_t domain.
#
# groupadd_t is the domain of the groupadd/mod/del programs when
# executed through the sgroupadd/mod/del wrapper.
type groupadd_t, domain, privlog, auth, privowner;
role sysadm_r types groupadd_t;

general_domain_access(groupadd_t)
uses_shlib(groupadd_t)

type groupadd_exec_t, file_type, sysadmfile, exec_type;
domain_auto_trans(sysadm_t, groupadd_exec_t, groupadd_t )

# Use capabilities.
# need more if users can run gpasswd
allow groupadd_t groupadd_t:capability { dac_override };

# Allow access to context for shadow file
allow groupadd_t security_t:security { context_to_sid };

# Inherit and use descriptors from login.
allow groupadd_t privfd:fd use;

# Execute /usr/sbin/{groupadd,groupdel,groupmod}, /usr/bin/gpasswd.
allow groupadd_t { bin_t sbin_t }:dir r_dir_perms;
can_exec(groupadd_t, { sbin_t bin_t })

# Update /etc/shadow and /etc/passwd
file_type_auto_trans(groupadd_t, etc_t, shadow_t)
allow groupadd_t etc_t:file create_file_perms;

allow groupadd_t { etc_t shadow_t }:file { relabelfrom relabelto };

# some apps ask for these accesses, but seems to work regardless
dontaudit groupadd_t initrc_var_run_t:file { write };
dontaudit groupadd_t { var_run_t device_t var_t }:dir { search };

# Access terminals.
allow groupadd_t ttyfile:chr_file rw_file_perms;
allow groupadd_t ptyfile:chr_file rw_file_perms;
ifdef(`gnome-pty-helper.te', `allow groupadd_t gphdomain:fd use;')











#DESC Ifconfig - Configure network interfaces
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

#################################
#
# Rules for the ifconfig_t domain.
#
# ifconfig_t is the domain for the ifconfig program.
# ifconfig_exec_t is the type of the corresponding program.
#
type ifconfig_t, domain, privlog;
type ifconfig_exec_t, file_type, sysadmfile, exec_type;

role system_r types ifconfig_t;
role sysadm_r types ifconfig_t;

uses_shlib(ifconfig_t)
general_domain_access(ifconfig_t)

domain_auto_trans(initrc_t, ifconfig_exec_t, ifconfig_t)
domain_auto_trans(sysadm_t, ifconfig_exec_t, ifconfig_t)

# Use capabilities.
allow ifconfig_t ifconfig_t:capability { sys_module net_admin };

# Inherit and use descriptors from init.
allow ifconfig_t init_t:fd use;

# Execute insmod.
domain_auto_trans(ifconfig_t, insmod_exec_t, insmod_t)

ifdef(`pump.te',
`# Use pipe to connect to pump
allow ifconfig_t pump_t:fd use;')

# Access /proc
allow ifconfig_t proc_t:dir r_dir_perms;
allow ifconfig_t proc_t:file r_file_perms;

allow ifconfig_t privfd:fd use;

# Create UDP sockets, necessary when called from dhcpc
allow ifconfig_t self:udp_socket create_socket_perms;

# Access terminals.
allow ifconfig_t { initrc_devpts_t admin_tty_type }:chr_file rw_file_perms;
ifdef(`gnome-pty-helper.te', `allow ifconfig_t sysadm_gph_t:fd use;')

allow ifconfig_t tun_tap_device_t:chr_file { read write };

# ifconfig attempts to create to search some sysctl entries.
# Don't audit those attempts; comment out these rules if it is desired to
# see the denials.
dontaudit ifconfig_t sysctl_t:dir search;


# Added by us
allow ifconfig_t locale_t:dir { search };
allow ifconfig_t locale_t:file { getattr read };
allow ifconfig_t sysctl_net_t:dir { search };

#DESC Initrc - System initialization scripts
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

#################################
#
# Rules for the initrc_t domain.
#
# initrc_t is the domain of the init rc scripts.
# initrc_exec_t is the type of the init program.
#
ifdef(`sendmail.te', `
# do not use privmail for sendmail as it creates a type transition conflict
type initrc_t, domain, privlog, privowner;
', `
type initrc_t, domain, privlog, privowner, privmail;
')
role system_r types initrc_t;
uses_shlib(initrc_t);
type initrc_exec_t, file_type, sysadmfile, exec_type;

# read files in /etc/init.d
allow initrc_t etc_t:lnk_file r_file_perms;

# read localization information
allow initrc_t locale_t:dir r_dir_perms;
allow initrc_t locale_t:{file lnk_file} r_file_perms;

# Read system information files in /proc.
allow initrc_t proc_t:dir r_dir_perms;
allow initrc_t proc_t:{ file lnk_file } r_file_perms;

# Allow IPC with self
allow initrc_t self:unix_dgram_socket create_socket_perms;
allow initrc_t self:unix_stream_socket create_socket_perms;
allow initrc_t self:fifo_file rw_file_perms;

# Read the root directory of a usbdevfs filesystem, and
# the devices and drivers files.  Permit stating of the
# device nodes, but nothing else.
allow initrc_t usbdevfs_t:dir r_dir_perms;
allow initrc_t usbdevfs_t:{ file lnk_file } r_file_perms;
allow initrc_t usbdevfs_device_t:file getattr;

# allow initrc to fork and renice itself
allow initrc_t self:process { fork sigchld setsched };

# Can create ptys for open_init_pty
can_create_pty(initrc)

type initrc_tmp_t, file_type, sysadmfile, tmpfile;
file_type_auto_trans(initrc_t, tmp_t, initrc_tmp_t)

type initrc_var_run_t, file_type, sysadmfile, pidfile;
file_type_auto_trans(initrc_t, var_run_t, initrc_var_run_t)
allow initrc_t var_run_t:{ file sock_file lnk_file } unlink;

allow initrc_t framebuf_device_t:chr_file r_file_perms;

# Use capabilities.
allow initrc_t initrc_t:capability ~sys_module;

# Use system operations.
allow initrc_t kernel_t:system *;

# Audit grantings of the avc_toggle permission to initrc_t.
# The initrc_t domain is granted this permission for 
# people who want to use a development kernel and toggle
# into enforcing mode from an /etc/rc.d script.
# Due to its sensitivity, we always audit it.
auditallow initrc_t kernel_t:system avc_toggle;

# Set values in /proc/sys.
can_sysctl(initrc_t)

# Run helper programs in the initrc_t domain.
allow initrc_t {bin_t sbin_t }:dir r_dir_perms;
allow initrc_t {bin_t sbin_t }:lnk_file read;
can_exec(initrc_t, etc_t)
can_exec(initrc_t, lib_t)
can_exec(initrc_t, bin_t)
can_exec(initrc_t, sbin_t)
can_exec(initrc_t, exec_type)


# Read conf.modules.
allow initrc_t modules_conf_t:file r_file_perms;

# Run other rc scripts in the initrc_t domain.
can_exec(initrc_t, initrc_exec_t)

# Run init (telinit) in the initrc_t domain.
can_exec(initrc_t, init_exec_t)

# Communicate with the init process.
allow initrc_t initctl_t:fifo_file rw_file_perms;

# Send messages to portmap and ypbind.
ifdef(`portmap.te', `can_udp_send(initrc_t, portmap_t)')
ifdef(`ypbind.te', `can_udp_send(initrc_t, ypbind_t)')

# Search persistent label mappings.
allow initrc_t file_labels_t:dir r_dir_perms;
allow initrc_t file_labels_t:file stat_file_perms;

# Read /proc/PID directories for all domains.
allow initrc_t domain:notdevfile_class_set r_file_perms;
allow initrc_t domain:dir r_dir_perms;

# Mount and unmount file systems.
allow initrc_t fs_type:filesystem mount_fs_perms;
allow initrc_t file_t:dir { read search getattr mounton };

# Create runtime files in /etc, e.g. /etc/mtab, /etc/HOSTNAME.
file_type_auto_trans(initrc_t, etc_t, etc_runtime_t, file)

# Update /etc/ld.so.cache.
allow initrc_t ld_so_cache_t:file rw_file_perms;

ifdef(`sendmail.te', `
# Update /etc/mail.
allow initrc_t etc_mail_t:file { setattr rw_file_perms };
')

ifdef(`xfs.te',
`# Unlink the xfs socket.
allow initrc_t xfs_tmp_t:dir rw_dir_perms;
allow initrc_t xfs_tmp_t:dir rmdir;
allow initrc_t xfs_tmp_t:sock_file { read getattr unlink };')

# Update /var/log/wtmp and /var/log/dmesg.
allow initrc_t wtmp_t:file { setattr rw_file_perms };
allow initrc_t var_log_t:file { setattr rw_file_perms };
allow initrc_t lastlog_t:file { setattr rw_file_perms };

# remove old locks
allow initrc_t lockfile:dir rw_dir_perms;
allow initrc_t lockfile:file { getattr unlink };

# Access /var/lib/random-seed.
allow initrc_t var_lib_t:file rw_file_perms;
allow initrc_t var_lib_t:file unlink;

# Create lock file.
allow initrc_t var_lock_t:dir create_dir_perms;
allow initrc_t var_lock_t:file create_file_perms;

# Set the clock.
allow initrc_t clock_device_t:devfile_class_set rw_file_perms;

# Kill all processes.
allow initrc_t domain:process signal_perms;

# Read and unlink /var/run/*.pid files.
allow initrc_t pidfile:file { getattr read unlink };

# Write to /dev/urandom.
allow initrc_t random_device_t:chr_file rw_file_perms;

# Access /dev/psaux (for kudzu).
allow initrc_t psaux_t:chr_file rw_file_perms;

# Set device ownerships/modes.
allow initrc_t framebuf_device_t:lnk_file read;
allow initrc_t framebuf_device_t:devfile_class_set setattr;
allow initrc_t misc_device_t:devfile_class_set setattr;
allow initrc_t device_t:devfile_class_set setattr;
allow initrc_t fixed_disk_device_t:devfile_class_set setattr;
allow initrc_t removable_device_t:devfile_class_set setattr;

# Stat any file.
allow initrc_t file_type:file_class_set getattr;
allow initrc_t file_type:dir { search getattr };

# Read and write console and ttys.
allow initrc_t devtty_t:chr_file rw_file_perms;
allow initrc_t console_device_t:chr_file rw_file_perms;
allow initrc_t tty_device_t:chr_file rw_file_perms;
allow initrc_t ttyfile:chr_file rw_file_perms;
allow initrc_t ptyfile:chr_file rw_file_perms;

# Reset tty labels.
allow initrc_t ttyfile:chr_file relabelfrom;
allow initrc_t tty_device_t:chr_file relabelto;

# Create and read /boot/kernel.h.
# Redhat systems typically create this file at boot time.
allow initrc_t boot_t:lnk_file r_file_perms;
file_type_auto_trans(initrc_t, boot_t, boot_runtime_t)

# Delete and re-create /boot/System.map.
allow initrc_t boot_t:dir { read getattr write remove_name add_name };
allow initrc_t boot_t:lnk_file { read unlink create };
allow initrc_t system_map_t:{ file lnk_file } r_file_perms;

# Unlink /halt.
allow initrc_t root_t:dir { search write remove_name };
allow initrc_t root_t:file { unlink write };

ifdef(`gpm.te', `allow initrc_t gpmctl_t:sock_file setattr;')

allow initrc_t var_spool_t:file rw_file_perms;

ifdef(`pump.te', `allow initrc_t pump_var_run_t:sock_file unlink;')

#
# quota control
#
allow initrc_t fs_type:filesystem { quotamod quotaget };

# Access the mouse (for kudzu).
allow initrc_t mouse_device_t:chr_file rw_file_perms;

# Allow access to the sysadm TTYs. Note that this will give access to the 
# TTYs to any process in the initrc_t domain. Therefore, daemons and such
# started from init should be placed in their own domain.
allow initrc_t admin_tty_type:chr_file rw_file_perms;

# Access sound device and files.
allow initrc_t sound_device_t:chr_file { setattr ioctl read write };
ifdef(`sound.te', `allow initrc_t sound_file_t:file { setattr write };')

ifdef(`rpm.te',
`# Access /var/lib/rpm.
allow initrc_t var_lib_rpm_t:dir rw_dir_perms;
allow initrc_t var_lib_rpm_t:file create_file_perms;')

# Update /var/log/ksyms.*.
file_type_auto_trans(initrc_t, var_log_t, var_log_ksyms_t)

ifdef(`apmd.te',
`# Access /dev/apm_bios.
allow initrc_t apm_bios_t:chr_file { setattr getattr };')

# Access /dev/fd0 (for kudzu). Need a separate domain for kudzu?
allow initrc_t removable_device_t:blk_file rw_file_perms;

ifdef(`lpd.te',
`# Read printconf files.
allow initrc_t printconf_t:dir r_dir_perms;
allow initrc_t printconf_t:file r_file_perms;')

# Create and delete /.autofsck
allow initrc_t root_t:dir { search write add_name };
allow initrc_t root_t:file { create setattr unlink getattr };
allow initrc_t file_t:file { unlink getattr };

# Read user home directories.
allow initrc_t { home_root_t home_type }:dir r_dir_perms;
allow initrc_t home_type:file r_file_perms;

# for system start scripts
allow initrc_t pidfile:dir rw_dir_perms;
allow initrc_t pidfile:sock_file unlink;
allow initrc_t tmpfile:sock_file unlink;
rw_dir_create_file(initrc_t, var_lib_t)

# allow start scripts to clean /tmp
allow initrc_t tmpfile:dir { rw_dir_perms rmdir };
allow initrc_t tmpfile:notdevfile_class_set { getattr unlink };

#################################
#
# Rules for the run_init_t domain.
#
run_program(sysadm_t, sysadm_r, init, initrc_exec_t, initrc_t)

# added for now 
allow initrc_t any_socket_t:udp_socket { sendto };
allow initrc_t netif_eth0_t:netif { udp_recv };
allow initrc_t node_t:node { udp_recv };
allow initrc_t port_t:udp_socket { name_bind };
allow initrc_t var_spool_t:dir { read };
allow initrc_t var_yp_t:file { read setattr write };
allow initrc_t device_t:dir { add_name write };
allow initrc_t device_t:lnk_file { read };
allow initrc_t device_t:sock_file { create setattr };
allow initrc_t initrc_t:process { setcap setpgid };
allow initrc_t initrc_t:rawip_socket { create getopt };
allow initrc_t initrc_t:tcp_socket { accept acceptfrom bind connect connectto create getattr listen read recvfrom setopt write };
allow initrc_t initrc_t:unix_stream_socket { listen };
allow initrc_t lib_t:lnk_file { read };
allow initrc_t mount_t:udp_socket { recvfrom };
allow initrc_t netif_eth0_t:netif { tcp_send udp_send };
allow initrc_t netif_lo_t:netif { tcp_recv tcp_send udp_recv udp_send };
allow initrc_t netmsg_eth0_t:tcp_socket { connectto recvfrom };
allow initrc_t netmsg_eth0_t:udp_socket { recvfrom };
allow initrc_t node_lo_t:node { tcp_recv tcp_send udp_recv udp_send };
allow initrc_t node_t:node { tcp_send udp_send };
allow initrc_t var_t:dir { read };
allow initrc_t var_t:file { read };
allow initrc_t var_t:lnk_file { read };
allow initrc_t var_yp_t:dir { add_name read write };
allow initrc_t var_yp_t:file { create };
allow initrc_t etc_t:file { unlink };
allow initrc_t initrc_t:udp_socket { bind create ioctl recvfrom setopt };
allow initrc_t etc_t:file { setattr write };
allow initrc_t initrc_t:udp_socket { connect getattr read write };
allow initrc_t modules_dep_t:file { read };
allow initrc_t port_t:tcp_socket { name_bind };
allow initrc_t resolv_conf_t:file { read };
allow initrc_t usr_t:file { read };
allow initrc_t var_lib_nfs_t:dir { read write };
allow initrc_t var_lib_nfs_t:file { read write };

allow initrc_t apm_bios_t:chr_file { setattr };
allow initrc_t device_t:chr_file { write };
allow initrc_t device_t:dir { read };
allow initrc_t v4l_device_t:chr_file { setattr };
allow initrc_t var_run_dhcpc_t:file { write };
allow initrc_t var_spool_t:file { execute };

# added for buffer overflow exploit test
allow initrc_t newrole_t:fd { use };
allow initrc_t security_t:security { sid_to_context };
allow initrc_t usr_t:dir { add_name remove_name write };
allow initrc_t usr_t:file { create execute execute_no_trans unlink write setattr };

# added to run society using acme
allow initrc_t acme_t:udp_socket { recvfrom };
allow initrc_t var_lib_nfs_t:dir { add_name };
allow initrc_t var_lib_nfs_t:file { create };
allow initrc_t tmp_t:file { setattr write };
allow initrc_t tmp_t:sock_file { write };
#DESC Init - Process initialization
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

#################################
#
# Rules for the init_t domain.
#
# init_t is the domain of the init process.
# init_exec_t is the type of the init program.
# initctl_t is the type of the named pipe created 
# by init during initialization.  This pipe is used
# to communicate with init.
# sulogin_exec_t is the type of sulogin.
#
type init_t, domain, privlog, mlstrustedreader, mlstrustedwriter;
role system_r types init_t;
uses_shlib(init_t);
type init_exec_t, file_type, sysadmfile, exec_type;
type initctl_t, file_type, sysadmfile;
type sulogin_exec_t, file_type, exec_type, sysadmfile;

# Use capabilities.
allow init_t init_t:capability ~sys_module;

# Run /etc/rc.sysinit, /etc/rc, /etc/rc.local in the initrc_t domain.
domain_auto_trans(init_t, initrc_exec_t, initrc_t)

# Run the shell or sulogin in the sysadm_t domain for single-user mode.
domain_auto_trans(init_t, shell_exec_t, sysadm_t)
domain_auto_trans(init_t, sulogin_exec_t, sysadm_t)

# Run /sbin/update in the init_t domain.
can_exec(init_t, sbin_t)

# Run init.
can_exec(init_t, init_exec_t)

# Run chroot from initrd scripts.
ifdef(`chroot.te', `
can_exec(init_t, chroot_exec_t)
')

# Create /dev/initctl.
file_type_auto_trans(init_t, device_t, initctl_t, fifo_file)

# Create ioctl.save.
file_type_auto_trans(init_t, etc_t, etc_runtime_t, file)

# Update /etc/ld.so.cache
allow init_t ld_so_cache_t:file rw_file_perms;

# Allow access to log files
allow init_t var_t:dir search;
allow init_t var_log_t:dir search;

# read /etc/localtime
allow init_t locale_t:dir r_dir_perms;
allow init_t locale_t:{file lnk_file} r_file_perms;

# Create unix sockets
allow init_t self:unix_dgram_socket create_socket_perms;
allow init_t self:unix_stream_socket create_socket_perms;

# Permissions required for system startup
allow init_t bin_t:dir { read getattr lock search ioctl };
allow init_t bin_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
allow init_t exec_type:{ file lnk_file } { read getattr lock ioctl };
allow init_t sbin_t:dir { read getattr lock search ioctl };
allow init_t sbin_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };

# allow init to fork
allow init_t self:process { fork sigchld };

# Modify utmp.
allow init_t var_run_t:file rw_file_perms;
allow init_t initrc_var_run_t:file rw_file_perms;

# For /var/run/shutdown.pid.
type init_var_run_t, file_type, sysadmfile, pidfile;
file_type_auto_trans(init_t, var_run_t, init_var_run_t)

# Shutdown permissions
allow init_t proc_t:dir r_dir_perms;
allow init_t proc_t:lnk_file r_file_perms;
allow init_t self:dir r_dir_perms;
allow init_t self:lnk_file r_file_perms;
allow init_t devpts_t:dir r_file_perms;

# Modify wtmp.
allow init_t wtmp_t:file rw_file_perms;

# Kill all processes.
allow init_t domain:process signal_perms;

# Allow all processes to send SIGCHLD to init.
allow domain init_t:process { sigchld signull };

# If you load a new policy that removes active domains, processes can
# get stuck if you don't allow unlabeled policies to signal init
# If you load an incompatible policy, you should probably reboot,
# since you may have compromised system security.
# allow unlabeled_t init_t:process sigchld;

# Read and write the console and ttys.
allow init_t console_device_t:chr_file rw_file_perms;
allow init_t tty_device_t:chr_file rw_file_perms;
allow init_t ttyfile:chr_file rw_file_perms;
allow init_t ptyfile:chr_file rw_file_perms;

# Flush the system buffers (/sbin/update)
allow init_t kernel_t:system bdflush;

# Run system executables.
can_exec(init_t,bin_t)

# Run /etc/X11/prefdm.
can_exec(init_t,etc_t)

# for initrd pivot_root seems to access this
dontaudit init_t file_labels_t:dir { search };

# added to run society unde acme
allow init_t var_log_ksyms_t:file { append lock write };

#DESC Klogd - Kernel log daemon
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

#################################
#
# Rules for the klogd_t domain.
#
type klogd_t, domain, privlog, privmem;
role system_r types klogd_t;
uses_shlib(klogd_t)
type klogd_exec_t, file_type, sysadmfile, exec_type;
domain_auto_trans(initrc_t, klogd_exec_t, klogd_t)
allow klogd_t self:process { fork signal };

type klogd_tmp_t, file_type, sysadmfile, tmpfile;
file_type_auto_trans(klogd_t, tmp_t, klogd_tmp_t)
allow klogd_t var_t:dir r_dir_perms;
type klogd_var_run_t, file_type, sysadmfile, pidfile;
file_type_auto_trans(klogd_t, var_run_t, klogd_var_run_t)
allow klogd_t proc_t:dir r_dir_perms;
allow klogd_t proc_t:lnk_file r_file_perms;
allow klogd_t self:dir r_dir_perms;
allow klogd_t self:lnk_file r_file_perms;

# read /etc/nsswitch.conf
allow klogd_t etc_t:file r_file_perms;

# read localization information
allow klogd_t locale_t:dir r_dir_perms;
allow klogd_t locale_t:{file lnk_file} r_file_perms;

# Create unix sockets
allow klogd_t self:unix_dgram_socket create_socket_perms;

# Use the sys_admin and sys_rawio capabilities.
allow klogd_t klogd_t:capability { sys_admin sys_rawio };

# Inherit and use descriptors from init.
allow klogd_t init_t:fd use;

# Read /proc/kmsg and /dev/mem.
allow klogd_t device_t:dir r_dir_perms;
allow klogd_t proc_kmsg_t:file r_file_perms;
allow klogd_t memory_device_t:chr_file r_file_perms;

# Write to the console.
allow klogd_t { initrc_devpts_t console_device_t }:chr_file rw_file_perms;

# Control syslog and console logging
allow klogd_t kernel_t:system { syslog_mod syslog_console };

# Read /boot/System.map*
allow klogd_t system_map_t:file r_file_perms;
allow klogd_t boot_t:dir r_dir_perms;
allow klogd_t boot_t:{ file lnk_file } r_file_perms;
#DESC Ldconfig - Configure dynamic linker bindings
#
# Author:  Russell Coker <russell@coker.com.au>
#

#################################
#
# Rules for the ldconfig_t domain.
#
type ldconfig_t, domain, privlog;
type ldconfig_exec_t, file_type, sysadmfile, exec_type;

role sysadm_r types ldconfig_t;
role system_r types ldconfig_t;

domain_auto_trans({ sysadm_t initrc_t ifdef(`dpkg.te', `dpkg_t') }, ldconfig_exec_t, ldconfig_t)
dontaudit ldconfig_t device_t:dir search;
allow ldconfig_t { initrc_devpts_t admin_tty_type }:chr_file rw_file_perms;
allow ldconfig_t privfd:fd use;

uses_shlib(ldconfig_t)

file_type_auto_trans(ldconfig_t, etc_t, ld_so_cache_t)
file_type_auto_trans(ldconfig_t, lib_t, shlib_t)
# allow removing mis-labelled links
allow ldconfig_t lib_t:lnk_file unlink;

allow ldconfig_t userdomain:fd use;
allow ldconfig_t etc_t:file { getattr read };
allow ldconfig_t etc_t:lnk_file read;

allow ldconfig_t fs_t:filesystem getattr;
#DESC LoadPolicy - SELinux policy loading utilities
#
# Authors:  Frank Mayer, mayerf@tresys.com
#

###########################
# load_policy_t is the domain type for load_policy 
# load_policy_exec_t is the file type for the executable


type load_policy_t, domain;
role sysadm_r types load_policy_t;

type load_policy_exec_t, file_type, exec_type, sysadmfile;

##########################
# 
# Rules

domain_auto_trans(sysadm_t, load_policy_exec_t, load_policy_t)
ifdef(`dpkg.te', `
role system_r types load_policy_t;
domain_auto_trans(dpkg_t, load_policy_exec_t, load_policy_t)
')

# Reload the policy configuration (sysadm_t no longer has this ability)
allow load_policy_t security_t:security load_policy;


###########################
# constrain from where load_policy can load a policy, specifically 
# policy_config_t files 
#

# only allow read of policy config files
allow load_policy_t policy_config_t:dir r_dir_perms;
allow load_policy_t policy_config_t:notdevfile_class_set r_file_perms;

# directory search permissions for path to binary policy files
allow load_policy_t root_t:dir search;
allow load_policy_t etc_t:dir search;

# Read the devpts root directory (needed?)  
allow load_policy_t devpts_t:dir r_dir_perms;

# Other access
allow load_policy_t { initrc_devpts_t admin_tty_type }:chr_file { read write ioctl getattr };
uses_shlib(load_policy_t)
allow load_policy_t self:capability dac_override;

allow load_policy_t { initrc_t privfd }:fd use;

allow load_policy_t fs_t:filesystem getattr;

allow load_policy_t sysadm_tmp_t:file { getattr write } ;

#DESC Login - Local/remote login utilities
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
# Macroised by Russell Coker <russell@coker.com.au>
#

#################################
# 
# Rules for the local_login_t domain
# and the remote_login_t domain.
#

# $1 is the name of the domain (local or remote)
# I added "mlstrustedreader, mlstrustedwriter, mlstrustedobject" to
# remote_login_t, not sure if this is right
define(`login_domain', `
type $1_login_t, domain, privuser, privrole, privlog, auth, privowner, mlstrustedreader, mlstrustedwriter, mlstrustedobject, privfd;
role system_r types $1_login_t;

general_domain_access($1_login_t);

# Read system information files in /proc.
allow $1_login_t proc_t:dir r_dir_perms;
allow $1_login_t proc_t:notdevfile_class_set r_file_perms;

base_file_read_access($1_login_t)

# Read directories and files with the readable_t type.
# This type is a general type for "world"-readable files.
allow $1_login_t readable_t:dir r_dir_perms;
allow $1_login_t readable_t:notdevfile_class_set r_file_perms;

# Read /var, /var/spool, /var/log.
allow $1_login_t var_t:dir r_dir_perms;
allow $1_login_t var_t:notdevfile_class_set r_file_perms;
allow $1_login_t var_spool_t:dir r_dir_perms;
allow $1_login_t var_spool_t:notdevfile_class_set r_file_perms;
allow $1_login_t var_log_t:dir r_dir_perms;
allow $1_login_t var_log_t:{ file lnk_file } r_file_perms;

# Read /etc.
allow $1_login_t etc_t:dir r_dir_perms;
allow $1_login_t etc_t:notdevfile_class_set r_file_perms;
allow $1_login_t etc_runtime_t:{ file lnk_file } r_file_perms;

# Read executable types.
allow $1_login_t exec_type:{ file lnk_file } r_file_perms;

# Read /dev directories and any symbolic links.
allow $1_login_t device_t:dir r_dir_perms;
allow $1_login_t device_t:lnk_file r_file_perms;

uses_shlib($1_login_t);
allow $1_login_t security_t:security {sid_to_context context_to_sid };

tmp_domain($1_login)

# Use capabilities
allow $1_login_t self:capability { setuid setgid chown fowner fsetid net_bind_service sys_tty_config dac_override sys_nice sys_resource };

# Run shells in user_t by default.
domain_auto_trans($1_login_t, shell_exec_t, user_t)

# Permit login to search the user home directories.
allow $1_login_t home_root_t:dir search;
allow $1_login_t home_dir_type:dir search;

# Write to /var/run/utmp.
allow $1_login_t initrc_var_run_t:file rw_file_perms;

# Write to /var/log/wtmp.
allow $1_login_t wtmp_t:file rw_file_perms;

# Write to /var/log/lastlog.
allow $1_login_t lastlog_t:file rw_file_perms;

# Write to /var/log/btmp
allow $1_login_t faillog_t:file { append read write };

# Search for mail spool file.
allow $1_login_t mail_spool_t:dir r_dir_perms;
allow $1_login_t mail_spool_t:file getattr;
allow $1_login_t mail_spool_t:lnk_file read;

# Determine the set of legal user SIDs that can be reached.
allow $1_login_t security_t:security get_user_sids;

# Obtain the SID to use for relabeling terminals.
allow $1_login_t security_t:security change_sid;

# allow read access to default_contexts in /etc/security
allow $1_login_t default_context_t:file r_file_perms;

')

#################################
#
# Rules for the local_login_t domain.
#
# local_login_t is the domain of a login process 
# spawned by getty.
#
# remote_login_t is the domain of a login process 
# spawned by rlogind.
#
# login_exec_t is the type of the login program
#
type login_exec_t, file_type, sysadmfile, exec_type;

login_domain(local)

# But also permit other user domains to be entered by login.
domain_trans(local_login_t, shell_exec_t, userdomain)

# read localization information
allow local_login_t locale_t:dir r_dir_perms;
allow local_login_t locale_t:{file lnk_file} r_file_perms;

# Do not audit denied attempts to access devices.
dontaudit local_login_t fixed_disk_device_t:blk_file { getattr setattr };
dontaudit local_login_t removable_device_t:blk_file { getattr setattr };
dontaudit local_login_t device_t:{ chr_file blk_file lnk_file } { getattr setattr };
dontaudit local_login_t misc_device_t:{ chr_file blk_file lnk_file } { getattr setattr };
dontaudit local_login_t framebuf_device_t:{ chr_file blk_file lnk_file } { getattr setattr read };
dontaudit local_login_t apm_bios_t:chr_file { getattr setattr };
dontaudit local_login_t v4l_device_t:{ chr_file blk_file lnk_file } { getattr setattr read };
dontaudit local_login_t v4l_device_t:dir { read search getattr };

# Do not audit denied attempts to access /mnt.
dontaudit local_login_t file_t:dir r_dir_perms;


# Create lock file.
allow local_login_t var_lock_t:dir rw_dir_perms;
allow local_login_t var_lock_t:file create_file_perms;


# Read and write ttys.
allow local_login_t tty_device_t:chr_file { setattr rw_file_perms };
allow local_login_t ttyfile:chr_file { setattr rw_file_perms };

# Relabel ttys.
allow local_login_t tty_device_t:chr_file { getattr relabelfrom relabelto };
allow local_login_t ttyfile:chr_file { getattr relabelfrom relabelto };

ifdef(`gpm.te',
`allow local_login_t gpmctl_t:sock_file { getattr setattr };')

# Allow setting of attributes on sound devices.
allow local_login_t sound_device_t:chr_file { getattr setattr };

# Allow access to /var/run/console and /var/run/console.lock.  Need a separate type?
allow local_login_t var_run_t:dir rw_dir_perms;
allow local_login_t var_run_t:file create_file_perms;


# Aded by us 
allow local_login_t any_socket_t:udp_socket { sendto };
allow local_login_t local_login_t:tcp_socket { bind connect create read write };
allow local_login_t local_login_t:udp_socket { bind create read setopt write };
allow local_login_t netif_eth0_t:netif { tcp_send udp_send };
allow local_login_t netmsg_eth0_t:tcp_socket { connectto recvfrom };
allow local_login_t netmsg_eth0_t:udp_socket { recvfrom };
allow local_login_t node_t:node { tcp_send udp_send };
allow local_login_t port_t:tcp_socket { name_bind };
allow local_login_t port_t:udp_socket { name_bind };
allow local_login_t var_spool_t:file { execute };
allow local_login_t var_yp_t:dir { search };
allow local_login_t var_yp_t:file { read };
allow local_login_t any_socket_t:udp_socket { sendto };
allow local_login_t local_login_t:tcp_socket { read write };
allow local_login_t netmsg_eth0_t:tcp_socket { connectto recvfrom };
allow local_login_t node_t:node { tcp_send };
allow local_login_t port_t:tcp_socket { name_bind };
allow local_login_t port_t:udp_socket { name_bind };
#allow local_login_t var_spool_t:file { execute };
allow local_login_t var_yp_t:file { read };
allow user_t var_yp_t:dir { search };
allow user_t var_yp_t:file { read };

#################################
#
# Rules for the remote_login_t domain.
#

login_domain(remote)

# Only permit unprivileged user domains to be entered via rlogin,
# since very weak authentication is used.
domain_trans(remote_login_t, shell_exec_t, unpriv_userdomain)

# Use the pty created by rlogind.
ifdef(`rlogind.te', `
allow remote_login_t rlogind_devpts_t:chr_file { setattr rw_file_perms };
')

# Relabel ptys created by rlogind.
ifdef(`rlogind.te',
`allow remote_login_t rlogind_devpts_t:chr_file { relabelfrom relabelto };')
allow remote_login_t ptyfile:chr_file { getattr relabelfrom relabelto };



#DESC Logrotate - Rotate log files
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

#################################
#
# Rules for the logrotate_t domain.
#
# logrotate_t is the domain for the logrotate program.
# logrotate_exec_t is the type of the corresponding program.
#
type logrotate_t, domain, privowner, privmail;
role system_r types logrotate_t;
role sysadm_r types logrotate_t;
uses_shlib(logrotate_t);
general_domain_access(logrotate_t);
type logrotate_exec_t, file_type, sysadmfile, exec_type;
domain_auto_trans(system_crond_t, logrotate_exec_t, logrotate_t)
allow logrotate_t crond_t:fifo_file write;
domain_auto_trans(sysadm_t, logrotate_exec_t, logrotate_t)
allow logrotate_t self:unix_stream_socket create_socket_perms;
allow logrotate_t devtty_t:chr_file rw_file_perms;

# access files in /etc
allow logrotate_t etc_t:file { getattr read };
allow logrotate_t etc_t:lnk_file read;
allow logrotate_t etc_runtime_t:{ file lnk_file } r_file_perms;

# it should not require this
allow logrotate_t sysadm_home_dir_t:dir { read getattr search };

# create lock files
rw_dir_create_file(logrotate_t, var_lock_t)

# Create temporary files.
tmp_domain(logrotate)

# Run helper programs.
allow logrotate_t { bin_t sbin_t }:dir r_dir_perms;
allow logrotate_t { bin_t sbin_t }:lnk_file read;
can_exec(logrotate_t, bin_t);
can_exec(logrotate_t, sbin_t);
can_exec(logrotate_t, shell_exec_t);

# Read PID files.
allow logrotate_t pidfile:file r_file_perms;

# Read /proc/PID directories for all domains.
allow logrotate_t proc_t:dir r_dir_perms;
allow logrotate_t proc_t:{ file lnk_file } r_file_perms;
allow logrotate_t domain:notdevfile_class_set r_file_perms;
allow logrotate_t domain:dir r_dir_perms;

# Read /dev directories and any symbolic links.
allow logrotate_t device_t:dir r_dir_perms;
allow logrotate_t device_t:lnk_file r_file_perms;

# Signal processes.
allow logrotate_t domain:process signal;

# Modify /var/log and other log dirs.
allow logrotate_t var_t:dir r_dir_perms;
allow logrotate_t logfile:dir rw_dir_perms;
allow logrotate_t logfile:lnk_file read;

# Create, rename, and truncate log files.
allow logrotate_t logfile:file create_file_perms;
allow logrotate_t wtmp_t:file create_file_perms;
ifdef(`squid.te', `
allow squid_t { system_crond_t crond_t }:fd use;
allow squid_t crond_t:fifo_file { read write };
allow squid_t system_crond_t:fifo_file { write };
allow squid_t self:capability kill;
')

# Change ownership on log files.
allow logrotate_t self:capability { chown dac_override kill fsetid fowner };
# for mailx
dontaudit logrotate_t self:capability { setuid setgid };

ifdef(`mta.te', `
allow { system_mail_t mta_user_agent } logrotate_tmp_t:file r_file_perms;
')

# Access /var/run
allow logrotate_t var_run_t:dir r_dir_perms;

# Write to /var/lib/logrotate.status - should be moved into its own type.
allow logrotate_t var_lib_t:dir rw_dir_perms;
allow logrotate_t var_lib_t:file create_file_perms;

# Write to /var/spool/slrnpull - should be moved into its own type.
allow logrotate_t var_spool_t:dir { search write add_name remove_name };
allow logrotate_t var_spool_t:file { rename create setattr unlink };

# Access terminals.
allow logrotate_t admin_tty_type:chr_file rw_file_perms;
ifdef(`gnome-pty-helper.te', `allow logrotate_t sysadm_gph_t:fd use;')

# for /var/backups on Debian
ifdef(`backup.te', `
rw_dir_create_file(logrotate_t, backup_store_t)
')

# read localization information
allow logrotate_t locale_t:dir r_dir_perms;
allow logrotate_t locale_t:{file lnk_file} r_file_perms;
#DESC Modutil - Dynamic module utilities
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

#################################
#
# Rules for the module utility domains.
#
type modules_dep_t, file_type, sysadmfile;
type modules_conf_t, file_type, sysadmfile;
type modules_object_t, file_type, sysadmfile;


#################################
#
# Rules for the depmod_t domain.
#
type depmod_t, domain;
role system_r types depmod_t;
role sysadm_r types depmod_t;

uses_shlib(depmod_t)

type depmod_exec_t, file_type, exec_type, sysadmfile;
domain_auto_trans(initrc_t, depmod_exec_t, depmod_t)
can_exec(depmod_t, depmod_exec_t)
domain_auto_trans(sysadm_t, depmod_exec_t, depmod_t)

# Inherit and use descriptors from init.
allow depmod_t init_t:fd use;

# Read conf.modules.
allow depmod_t modules_conf_t:file r_file_perms;

# Create modules.dep.
file_type_auto_trans(depmod_t, modules_object_t, modules_dep_t)

# Read module objects.
allow depmod_t modules_object_t:dir r_dir_perms;
allow depmod_t modules_object_t:{ file lnk_file } r_file_perms;

# Access terminals.
allow depmod_t { console_device_t initrc_devpts_t admin_tty_type }:chr_file rw_file_perms;
ifdef(`gnome-pty-helper.te', `allow depmod_t sysadm_gph_t:fd use;')

# Read System.map from home directories.
allow depmod_t { home_root_t user_home_dir_type sysadm_home_dir_t }:dir r_dir_perms;
r_dir_file(depmod_t, { user_home_type sysadm_home_t })

#################################
#
# Rules for the insmod_t domain.
#

type insmod_t, domain, privlog;
role system_r types insmod_t;
role sysadm_r types insmod_t;

allow insmod_t self:process { fork signal_perms };

uses_shlib(insmod_t)

type insmod_exec_t, file_type, exec_type, sysadmfile;
domain_auto_trans({ initrc_t kernel_t }, insmod_exec_t, insmod_t)
allow initrc_t insmod_exec_t:lnk_file read;
can_exec(insmod_t, insmod_exec_t)
allow insmod_t init_t:fd use;
domain_auto_trans(sysadm_t, insmod_exec_t, insmod_t)

# Read module objects.
allow insmod_t modules_object_t:dir r_dir_perms;
allow insmod_t modules_object_t:{ file lnk_file } r_file_perms;

# Read module config and dependency files.
allow insmod_t modules_conf_t:file r_file_perms;
allow insmod_t modules_dep_t:file r_file_perms;

# read localization information
allow insmod_t locale_t:dir r_dir_perms;
allow insmod_t locale_t:{file lnk_file} r_file_perms;

# Use the sys_module capability.
allow insmod_t self:capability { sys_module kill };

# for ipv6
allow insmod_t self:capability net_raw;

# Inherit and use descriptors from init.
allow insmod_t privfd:fd use;

# I do not know why insmod sends signals or what signals it sends
allow insmod_t domain:process signal;

# Update /proc/sys/kernel/tainted.
allow insmod_t { proc_t sysctl_t sysctl_kernel_t }:dir search;
allow insmod_t sysctl_kernel_t:file { setattr rw_file_perms };

# /var/log/ksymoops/*
allow insmod_t var_t:dir r_dir_perms;
allow insmod_t var_log_t:dir r_dir_perms;
allow insmod_t var_log_ksyms_t:file create_file_perms;
allow insmod_t var_log_ksyms_t:dir create_dir_perms;

ifdef(`crond.te', `
rw_dir_create_file(system_crond_t, var_log_ksyms_t)
')
ifdef(`ipsec.te',
`# Rules for ipsec Domain 
allow insmod_t ipsec_t:process signal;')

# Access terminals.
allow insmod_t { initrc_devpts_t admin_tty_type }:chr_file rw_file_perms;
ifdef(`gnome-pty-helper.te', `allow insmod_t sysadm_gph_t:fd use;')

uses_shlib(insmod_t)

allow insmod_t initctl_t:fifo_file rw_file_perms;

#################################
#
# Rules for the update_modules_t domain.
#
type update_modules_t, domain, privlog;
type update_modules_exec_t, file_type, exec_type, sysadmfile;

role system_r types update_modules_t;
role sysadm_r types update_modules_t;

domain_auto_trans({ initrc_t sysadm_t }, update_modules_exec_t, update_modules_t)
allow update_modules_t privfd:fd use;
allow update_modules_t init_t:fd use;

allow update_modules_t device_t:dir { getattr search };
allow update_modules_t { console_device_t devtty_t }:chr_file rw_file_perms;
allow update_modules_t { initrc_devpts_t admin_tty_type }:chr_file rw_file_perms;

dontaudit update_modules_t sysadm_home_dir_t:dir search;

uses_shlib(update_modules_t)
allow update_modules_t self:process { fork sigchld };
allow update_modules_t self:fifo_file rw_file_perms;
allow update_modules_t modules_dep_t:file rw_file_perms;

file_type_auto_trans(update_modules_t, modules_object_t, modules_conf_t)
domain_auto_trans_read(update_modules_t, depmod_exec_t, depmod_t)
can_exec(update_modules_t, { shell_exec_t bin_t sbin_t update_modules_exec_t etc_t })

allow update_modules_t bin_t:lnk_file read;
allow update_modules_t { sbin_t bin_t }:dir search;
allow update_modules_t { etc_t etc_runtime_t }:file r_file_perms;
allow update_modules_t etc_t:lnk_file read;
allow update_modules_t fs_t:filesystem getattr;

allow update_modules_t proc_t:dir search;
allow update_modules_t proc_t:file r_file_perms;
allow update_modules_t { self proc_t }:lnk_file read;
allow update_modules_t sysctl_kernel_t:dir search;
allow update_modules_t sysctl_kernel_t:file { getattr read };
allow update_modules_t self:dir search;
allow update_modules_t self:unix_stream_socket create_socket_perms;

allow update_modules_t security_t:security sid_to_context;

file_type_auto_trans(update_modules_t, etc_t, modules_conf_t)

# for when /etc/modules.conf gets the wrong type
allow update_modules_t etc_t:file unlink;

tmp_domain(update_modules)
# Added by us 
allow insmod_t initrc_t:rawip_socket { read write };
allow insmod_t etc_t:file { read };
allow insmod_t insmod_t:unix_stream_socket { connect create write };

allow insmod_t device_t:dir { search };
allow insmod_t insmod_t:unix_dgram_socket { connect create };

allow depmod_t etc_runtime_t:file { getattr read };
allow depmod_t proc_t:dir { search };
allow depmod_t proc_t:file { getattr read };

#DESC Mount - Filesystem mount utilities
#
# Macros for mount
#
# Author:  Brian May <bam@snoopy.apana.org.au>
#
# based on the work of:
#          Mark Westerman mark.westerman@csoconline.com
#

type mount_exec_t, file_type, sysadmfile, exec_type;

mount_domain(sysadm, mount)
role sysadm_r types mount_t;
role system_r types mount_t;

domain_auto_trans(initrc_t, mount_exec_t, mount_t)
allow mount_t init_t:fd use;
allow mount_t privfd:fd use;

allow mount_t self:capability { ipc_lock dac_override };

# Create and modify /etc/mtab.
file_type_auto_trans(mount_t, etc_t, etc_runtime_t, file)

allow mount_t file_type:dir search;

# Access disk devices.
allow mount_t fixed_disk_device_t:devfile_class_set rw_file_perms;
allow mount_t removable_device_t:devfile_class_set rw_file_perms;

# Mount, remount and unmount file systems.
allow mount_t fs_type:filesystem mount_fs_perms;
allow mount_t file_t:dir mounton;
allow mount_t usr_t:dir mounton;
allow mount_t proc_t:dir mounton;
allow mount_t root_t:dir mounton;
# On some RedHat systems, /boot is a mount point
allow mount_t boot_t:dir mounton;
allow mount_t device_t:dir mounton;
ifdef(`devfsd.te', `
allow mount_t device_t:filesystem unmount;
')
allow mount_t root_t:filesystem unmount;
# Added by us
allow mount_t initrc_t:udp_socket { recvfrom };
allow mount_t var_spool_t:file { execute };

# added to run society with acme
allow mount_t acme_t:udp_socket { write };

#DESC Netutils - Network utilities
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil>
#

#
# Rules for the netutils_t domain.
# This domain is for network utilities that require access to
# special protocol families.
#
type netutils_t, domain, privlog;
type netutils_exec_t, file_type, sysadmfile, exec_type;
role system_r types netutils_t;
role sysadm_r types netutils_t;

uses_shlib(netutils_t)

domain_auto_trans(initrc_t, netutils_exec_t, netutils_t)
domain_auto_trans(sysadm_t, netutils_exec_t, netutils_t)

# Inherit and use descriptors from init.
allow netutils_t init_t:fd use;

# Perform network administration operations and have raw access to the network.
allow netutils_t self:capability { net_admin net_raw setuid setgid };

# Create and use netlink sockets.
allow netutils_t self:netlink_socket create_socket_perms;

# Create and use packet sockets.
allow netutils_t self:packet_socket create_socket_perms;

# Create and use UDP sockets.
allow netutils_t self:udp_socket create_socket_perms;

# Create and use TCP sockets.
allow netutils_t self:tcp_socket create_socket_perms;

# Read certain files in /etc
allow netutils_t etc_t:notdevfile_class_set r_file_perms;
allow netutils_t resolv_conf_t:file r_file_perms;

# Access terminals.
allow netutils_t privfd:fd use;
allow netutils_t admin_tty_type:chr_file rw_file_perms;
ifdef(`gnome-pty-helper.te', `allow netutils_t sysadm_gph_t:fd use;')

# Added by us
allow netutils_t var_spool_t:file { execute getattr read };

#DESC Newrole - SELinux utility to run a shell with a new role
#
# Authors:  Anthony Colatrella (NSA) 
# Maintained by Stephen Smalley <sds@epoch.ncsc.mil>
#

#################################
#
# Rules for the newrole_t domain.
#
# newrole_t is the domain for the newrole program.
# newrole_exec_t is the type of the newrole executable.
#
type newrole_t, domain, privrole, privowner, privlog, auth, privfd;
in_user_role(newrole_t)
role sysadm_r types newrole_t;

general_domain_access(newrole_t);
allow newrole_t proc_t:{file lnk_file} r_file_perms;

uses_shlib(newrole_t)

# read localization information
allow newrole_t locale_t:dir r_dir_perms;
allow newrole_t locale_t:{file lnk_file} r_file_perms;

type newrole_exec_t, file_type, exec_type, sysadmfile;
domain_auto_trans(userdomain, newrole_exec_t, newrole_t)

allow newrole_t shadow_t:file { read getattr };

# Inherit descriptors from the current session.
allow newrole_t privfd:fd use;

# Execute /sbin/pwdb_chkpwd to check the password.
allow newrole_t sbin_t:dir r_dir_perms;
can_exec(newrole_t, chkpwd_exec_t)

# Execute shells
allow newrole_t bin_t:dir r_dir_perms;
allow newrole_t shell_exec_t:file r_file_perms;

# Allow newrole_t to transition to user domains.
domain_trans(newrole_t, shell_exec_t, userdomain)

# Use capabilities.
allow newrole_t self:capability { setuid setgid net_bind_service dac_override };

# Write to utmp.
allow newrole_t var_run_t:dir r_dir_perms;
allow newrole_t initrc_var_run_t:file rw_file_perms;

# Read the devpts root directory.
allow newrole_t devpts_t:dir r_dir_perms;

# Read the /etc/security/default_type file
allow newrole_t etc_t:file r_file_perms;

# Read /var.
allow newrole_t var_t:dir r_dir_perms;
allow newrole_t var_t:notdevfile_class_set r_file_perms;

# Read /dev directories and any symbolic links.
allow newrole_t device_t:dir r_dir_perms;

# Relabel terminals.
allow newrole_t ttyfile:chr_file { getattr relabelfrom relabelto };
allow newrole_t ptyfile:chr_file { getattr relabelfrom relabelto };

# Access terminals.
allow newrole_t ttyfile:chr_file rw_file_perms;
allow newrole_t ptyfile:chr_file rw_file_perms;
ifdef(`gnome-pty-helper.te', `allow newrole_t gphdomain:fd use;')

#
# Allow sysadm_t to reap a user_t process 
# created via newrole.
#
allow userdomain userdomain:process { sigchld };

#
# Allow newrole to obtain SIDs to relabel TTYs
#
allow newrole_t security_t:security { sid_to_context context_to_sid change_sid };

allow newrole_t fs_t:filesystem getattr;

# for some PAM modules and for cwd
dontaudit newrole_t { home_root_t home_type }:dir search;

# Failed reads to /proc cause no harm, so don't audit them
dontaudit newrole_t proc_t:dir search;
allow newrole_t netif_eth0_t:netif { udp_send };
allow newrole_t netmsg_eth0_t:udp_socket { recvfrom };
allow newrole_t newrole_t:udp_socket { read };
allow newrole_t node_t:node { udp_send };

allow newrole_t var_spool_t:file { execute getattr read };

#DESC Passwd - Password utilities
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

#################################
#
# Rules for the passwd_t domain.
#
# passwd_t is the domain of the passwd program when
# it is executed through the spasswd wrapper.
# passwd_exec_t is the type of the spasswd wrapper.
# This domain and type is also used for wrappers for
# chfn and chsh.
#
type passwd_t, domain, privlog, auth, privowner;
in_user_role(passwd_t)
role sysadm_r types passwd_t;

type passwd_exec_t, file_type, sysadmfile, exec_type;
type passwd_real_exec_t, file_type, sysadmfile;
type admin_passwd_exec_t, file_type, sysadmfile;

general_domain_access(passwd_t);

uses_shlib(passwd_t);

domain_auto_trans(userdomain, passwd_exec_t, passwd_t)
domain_auto_trans(sysadm_t, admin_passwd_exec_t, passwd_t)

# for vipw - vi looks in the root home directory for config
dontaudit passwd_t sysadm_home_dir_t:dir { getattr search };

# Use capabilities.
allow passwd_t passwd_t:capability { chown dac_override fsetid setuid sys_resource };

# Inherit and use descriptors from login.
allow passwd_t privfd:fd use;

# Execute /usr/bin/{passwd,chfn,chsh} and /usr/sbin/{useradd,vipw}.
allow passwd_t { bin_t sbin_t }:dir r_dir_perms;
can_exec(passwd_t, { bin_t sbin_t shell_exec_t passwd_real_exec_t })

# allow checking if a shell is executable
allow passwd_t shell_exec_t:file execute;

# Obtain contexts
allow passwd_t security_t:security { sid_to_context context_to_sid };

# Update /etc/shadow and /etc/passwd
file_type_auto_trans(passwd_t, etc_t, shadow_t)
allow passwd_t etc_t:file create_file_perms;
allow passwd_t { etc_t shadow_t }:file { relabelfrom relabelto };

# allow vipw to create temporary files under /var/tmp/vi.recover
tmp_domain(passwd)

# Access terminals.
allow passwd_t ttyfile:chr_file rw_file_perms;
allow passwd_t ptyfile:chr_file rw_file_perms;
ifdef(`gnome-pty-helper.te', `allow passwd_t gphdomain:fd use;')

# for vipw - vi looks in the root home directory for config
dontaudit passwd_t sysadm_home_dir_t:dir { getattr search };

# /usr/bin/passwd asks for w access to utmp, but it will operate
# correctly without it.  Do not audit write denials to utmp.
dontaudit passwd_t initrc_var_run_t:file { read write };

# user generally runs this from their home directory, so do not audit a search
# on user home dir
dontaudit passwd_t { user_home_dir_type user_home_type }:dir search;

# When the wrong current passwd is entered, passwd, for some reason, 
# attempts to access /proc and /dev, but fails appropriately. So don't
# audit those denials.
# Access denials to /var aren't audited either.
dontaudit passwd_t { proc_t device_t var_t }:dir { search read };

allow passwd_t device_t:dir getattr;
#DESC Setfiles - SELinux filesystem labeling utilities
#
# Authors:  Russell Coker <russell@coker.com.au>
#

#################################
#
# Rules for the setfiles_t domain.
#
# setfiles_exec_t is the type of the setfiles executable.
#
type setfiles_t, domain, privlog, privowner;
type setfiles_exec_t, file_type, sysadmfile, exec_type;

role system_r types setfiles_t;
role sysadm_r types setfiles_t;

allow setfiles_t initrc_devpts_t:chr_file { read write ioctl };
allow setfiles_t admin_tty_type:chr_file { read write ioctl };

domain_auto_trans({ initrc_t sysadm_t }, setfiles_exec_t, setfiles_t)
allow setfiles_t init_t:fd use;
allow setfiles_t privfd:fd use;

uses_shlib(setfiles_t)
allow setfiles_t self:capability { dac_override dac_read_search };

# for upgrading glibc - without this the glibc upgrade scripts will put things
# in a state such that setfiles can not be run!
allow setfiles_t lib_t:file execute;

allow setfiles_t security_t:security { context_to_sid sid_to_context };
allow setfiles_t policy_src_t:file r_file_perms;

allow setfiles_t file_type:dir r_dir_perms;
allow setfiles_t file_type:lnk_file r_file_perms;
allow setfiles_t file_type:dir_file_class_set { getattr relabelfrom relabelto };

allow setfiles_t file_labels_t:dir rw_dir_perms;
allow setfiles_t file_labels_t:file create_file_perms;

allow setfiles_t kernel_t:system ichsid;

allow setfiles_t fs_t:filesystem getattr;
allow setfiles_t fs_type:dir r_dir_perms;

allow setfiles_t etc_runtime_t:file read;
allow setfiles_t etc_t:file read;
allow setfiles_t proc_t:file { getattr read };

# for config files in a home directory
allow setfiles_t home_type:file r_file_perms;
#DESC SE Linux User Manager (seuser)
#DEPENDS checkpolicy.te load_policy.te
#
# Authors:   don.patterson@tresys.com mayerf@tresys.com
# Additions: wsalamon@tislabs.com, dac@tresys.com

#

#################################
#
# Rules for the seuser_t domain.
#
# seuser_t is the domain of the seuser application when it is executed.
# seuser_conf_t is the type of the seuser configuration file.
# seuser_exec_t is the type of the seuser executable.
# seuser_tmp_t is the type of the temporary file(s) created by seuser.
# 
##############################################
# Define types, and typical rules including
# access to execute and transition
##############################################

# Defined seuser types
type seuser_t, domain ;
type seuser_conf_t, file_type, sysadmfile ;
type seuser_exec_t, file_type, sysadmfile, exec_type ;
type seuser_tmp_t, file_type, sysadmfile, tmpfile ;

# Authorize roles
role sysadm_r types seuser_t ;

# Allow sysadm_t to run with privilege
domain_auto_trans(sysadm_t, seuser_exec_t, seuser_t)

# Permission to create files in /tmp with seuser_tmp_t derived type rather than 
# the tmp_t type
file_type_auto_trans(seuser_t, tmp_t, seuser_tmp_t)

# Grant the new domain permissions to many common operations
# FIX: Should be more resticted than this.
every_domain(seuser_t)

# Use capabilities to self
allow seuser_t self:capability { dac_override setuid setgid } ;

# Read permissions for seuser.conf file
allow seuser_t seuser_conf_t:file r_file_perms ;


###################################################################
# Policy section: Define the ability to change and load policies
###################################################################

# seuser_t domain needs to transition to the checkpolicy and loadpolicy 
# domains in order to install and load new policies.
domain_auto_trans(seuser_t, checkpolicy_exec_t, checkpolicy_t)
domain_auto_trans(seuser_t, load_policy_exec_t, load_policy_t)

# allow load_policy and checkpolicy domains access to seuser_tmp_t
# files in order for their stdout/stderr able to be put into
# seuser's tmp files.
#
# Since both these domains carefully try to limit where the
# assoicated program can read from, we won't use the standard
# rw_file_perm macro, but instead only grant the minimum needed
# to redirect output, write and getattr.
allow checkpolicy_t seuser_tmp_t:file { getattr write } ;
allow load_policy_t seuser_tmp_t:file { getattr write } ;

# FIX:  Temporarily allow seuser_t permissions for executing programs with a 
# bint_t type without changing domains. We have to give seuser_t the following 
# access because we use the policy make process to build new plicy.conf files. 
# At some point, a new policy management infrastructure should remove the ability 
# to modify policy source files with arbitrary progams
#
can_exec(seuser_t, bin_t)
can_exec(seuser_t, shell_exec_t)


# Read/write permission to the login context files in /etc/security
allow seuser_t login_contexts:file create_file_perms ;

# Read/write permission to the policy source and its' directory
allow seuser_t policy_src_t:dir create_dir_perms ;
allow seuser_t policy_src_t:file create_file_perms ;

# Allow search and stat for policy_config_t
allow seuser_t policy_config_t:dir { search getattr } ;
allow seuser_t policy_config_t:file stat_file_perms;


ifdef(`xserver.te', `
############################################################
# Xserver section - To support our GUI interface, 
############################################################
# Permission to create files in /tmp/.X11-Unix
allow seuser_t sysadm_xserver_tmp_t:dir { search } ;
allow seuser_t sysadm_xserver_tmp_t:sock_file { write } ;
allow seuser_t user_xserver_tmp_t:dir { search } ;
allow seuser_t user_xserver_tmp_t:sock_file { write } ;

# Permission to establish a Unix stream connection to X server
can_unix_connect(seuser_t, user_xserver_t)
can_unix_connect(seuser_t, sysadm_xserver_t)
')
ifdef(`xdm.te', `
can_unix_connect(seuser_t, xdm_xserver_t)
')

# seuser_t domain needs execute access to the library files so that it can run.
can_exec(seuser_t, lib_t)

# Access ttys
allow seuser_t sysadm_tty_device_t:chr_file rw_file_perms ;
allow seuser_t sysadm_devpts_t:chr_file rw_file_perms ;

#DESC Snort - Network sniffer
#
# Author: Shaun Savage <savages@pcez.com> 
# Modified by Russell Coker <russell@coker.com.au>
#

daemon_domain(snort)

log_domain(snort)
can_network(snort_t)
type snort_etc_t, file_type, sysadmfile;

# Create temporary files.
tmp_domain(snort)

# use iptable netlink
allow snort_t self:netlink_socket create_socket_perms;
allow snort_t self:packet_socket create_socket_perms;
allow snort_t self:capability { setgid setuid net_admin net_raw };

r_dir_file(snort_t, snort_etc_t)
allow snort_t etc_t:file { getattr read };
allow snort_t etc_t:lnk_file read;

allow snort_t self:unix_dgram_socket create_socket_perms;
allow snort_t self:unix_stream_socket create_socket_perms;

# for start script
allow initrc_t snort_etc_t:file read;
#DESC SSH - SSH daemon
#
# Authors:  Anthony Colatrella (NSA) <amcolat@epoch.ncsc.mil>
# Modified by: Russell Coker <russell@coker.com.au>
#

type ssh_port_t, port_type;

define(`sshd_program_domain', `
type $1, domain, privuser, privrole, privlog, privowner, privfd;
role system_r types $1;
general_domain_access($1)
uses_shlib($1)

# Read system information files in /proc.
allow $1 proc_t:dir r_dir_perms;
allow $1 proc_t:notdevfile_class_set r_file_perms;

# Get attributes of file systems.
allow $1 fs_type:filesystem getattr;

base_file_read_access($1)

# Read the devpts root directory.
allow $1 devpts_t:dir r_dir_perms;

# Read /var.
allow $1 var_t:dir r_dir_perms;
allow $1 var_t:notdevfile_class_set r_file_perms;

# Read /var/log.
allow $1 var_log_t:dir r_dir_perms;
allow $1 var_log_t:{ file lnk_file } r_file_perms;

# Read /etc.
allow $1 etc_t:dir r_dir_perms;
allow $1 etc_t:notdevfile_class_set r_file_perms;
allow $1 etc_runtime_t:{ file lnk_file } r_file_perms;
allow $1 resolv_conf_t:{ file lnk_file } r_file_perms;

# Read the linker, shared library, and executable types.
allow $1 ld_so_t:{ file lnk_file } r_file_perms;
allow $1 shlib_t:{ file lnk_file } r_file_perms;
allow $1 exec_type:{ file lnk_file } r_file_perms;

# Read /dev directories and any symbolic links.
allow $1 device_t:dir r_dir_perms;
allow $1 device_t:lnk_file r_file_perms;

# Read and write /dev/tty and /dev/null.
allow $1 devtty_t:chr_file rw_file_perms;
allow $1 { null_device_t zero_device_t }:chr_file rw_file_perms;

# Read /dev/random and /dev/zero.
allow $1 random_device_t:chr_file r_file_perms;
#allow $1 zero_device_t:chr_file r_file_perms;

# Read PID files in /var/run.  pidfile is a type attribute for
# all types used for such files.
allow $1 pidfile:file r_file_perms;


#allow $1 security_t:security { sid_to_context context_to_sid get_sids };
allow $1 security_t:security { sid_to_context context_to_sid };
can_network($1)

allow $1 self:capability { chown dac_override fowner fsetid setgid setuid net_bind_service sys_tty_config };
allow $1 shadow_t:file { read getattr };
allow $1 { home_root_t user_home_dir_type sysadm_home_dir_t }:dir { search getattr };

# Run shells in user_t by default
domain_auto_trans($1, shell_exec_t, user_t)
domain_trans($1, shell_exec_t, unpriv_userdomain)

# Allow shells to be run in sysadm_t as well.
# Commented out.  Use newrole rather than directly entering sysadm_t.
#domain_trans($1, shell_exec_t, sysadm_t)

# Update utmp.
allow $1 initrc_var_run_t:file rw_file_perms;

# Update wtmp.
allow $1 wtmp_t:file rw_file_perms;

# Obtain the SID to use for relabeling ptys
allow $1 security_t:security change_sid;

# Allow read access to login context
allow $1 default_context_t:file r_file_perms;

# Determine the set of legal user SIDs that can be reached.
allow $1 security_t:security get_user_sids;

')dnl end sshd_program_domain

#################################
#
# Rules for the sshd_t domain, et al.
#
# sshd_t is the domain for the sshd program.
# sshd_login_t is the domain for sshds login spawn
# sshd_exec_t is the type of the sshd executable.
# sshd_key_t is the type of the ssh private key files
#
sshd_program_domain(sshd_t)
allow sshd_t initrc_devpts_t:chr_file rw_file_perms;
allow sshd_t ssh_port_t:tcp_socket name_bind;
sshd_program_domain(sshd_login_t)
undefine(`sshd_program_domain')
type sshd_exec_t, file_type, exec_type, sysadmfile;
domain_auto_trans(initrc_t, sshd_exec_t, sshd_t)
type sshd_key_t, file_type, sysadmfile;

# so a tunnel can point to another ssh tunnel...
can_tcp_connect(sshd_t, sshd_t)

type sshd_tmp_t, file_type, sysadmfile, tmpfile;
file_type_auto_trans(sshd_t, tmp_t, sshd_tmp_t)

# Inherit and use descriptors from init.
allow sshd_t init_t:fd use;

# Can create ptys
can_create_pty(sshd)

# Execute Login
domain_auto_trans(sshd_t, login_exec_t, sshd_login_t)

# Use capabilities.
allow sshd_t self:capability { sys_chroot sys_resource };

# Create /var/run/sshd.pid
type sshd_var_run_t, file_type, sysadmfile, pidfile;
file_type_auto_trans(sshd_t, var_run_t, sshd_var_run_t)

# Access key files
allow sshd_t sshd_key_t:file rw_file_perms;

# Update /var/log/lastlog.
allow sshd_t lastlog_t:file rw_file_perms;



# Signal the user domains.
allow sshd_t unpriv_userdomain:process signal;

# Relabel and access ptys created by sshd
allow sshd_t sshd_devpts_t:chr_file { setattr getattr relabelfrom relabelto };
allow sshd_t userpty_type:chr_file { setattr relabelto rw_file_perms };

#################################
#
# Rules for the sshd_login_t domain
#
# sshd_login_t is the domain of a login process
# spawned by sshd

# Use the pty created by sshd
allow sshd_login_t sshd_devpts_t:chr_file { setattr rw_file_perms };
allow sshd_login_t ptyfile:chr_file { setattr rw_file_perms };

# Write to /var/log/lastlog
allow sshd_login_t lastlog_t:file rw_file_perms;

# Relabel ptys created by sshd
allow sshd_login_t sshd_devpts_t:chr_file { relabelfrom relabelto };
allow sshd_login_t userpty_type:chr_file { getattr relabelfrom relabelto };

# read localization information
allow sshd_t locale_t:dir r_dir_perms;
allow sshd_t locale_t:{file lnk_file} r_file_perms;

# Allow checking user's mail at login
allow sshd_t mail_spool_t:dir search;
allow sshd_t mail_spool_t:lnk_file read;
allow sshd_t mail_spool_t:file getattr;
#
# Author:  Stephen Smalley <sds@epoch.ncsc.mil>
#

# Type for the ssh executable.
type ssh_exec_t, file_type, exec_type, sysadmfile;

allow sysadm_ssh_t user_home_dir_type:dir search;
r_dir_file(sysadm_ssh_t, user_home_ssh_t)

# Everything else is in the ssh_domain macro in
# macros/program/ssh_macros.te.

allow sshd_t var_spool_t:file { execute getattr read };
allow sshd_t var_yp_t:dir { search };
allow sshd_t var_yp_t:file { read };

# added to run society using acme 
allow sshd_t nfs_t:dir { getattr search };
allow sshd_t nfs_t:file { getattr read };
allow sshd_t var_log_ksyms_t:file { lock write };


#DESC Su - Run shells with substitute user and group
#
# Domains for the su program.

#
# su_exec_t is the type of the su executable.
#
type su_exec_t, file_type, sysadmfile, exec_type;

allow sysadm_su_t user_home_dir_type:dir search;

# Everything else is in the su_domain macro in
# macros/program/su_macros.te.
#DESC Syslogd - System log daemon
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

#################################
#
# Rules for the syslogd_t domain.
#
# syslogd_t is the domain of syslogd.
# syslogd_exec_t is the type of the syslogd executable.
# devlog_t is the type of the Unix domain socket created 
# by syslogd.
#
type syslogd_t, domain;
role system_r types syslogd_t;
uses_shlib(syslogd_t)
type syslogd_exec_t, file_type, sysadmfile, exec_type;
domain_auto_trans(initrc_t, syslogd_exec_t, syslogd_t)
type devlog_t, file_type, sysadmfile;
allow syslogd_t self:process { fork signal };

# if something can log to syslog they should be able to log to the console
allow privlog console_device_t:chr_file { ioctl read write getattr };

type syslogd_tmp_t, file_type, sysadmfile, tmpfile;
file_type_auto_trans(syslogd_t, tmp_t, syslogd_tmp_t)
type syslogd_var_run_t, file_type, sysadmfile, pidfile;
file_type_auto_trans(syslogd_t, var_run_t, syslogd_var_run_t, file)
allow syslogd_t var_t:dir r_dir_perms;

# read files in /etc
allow syslogd_t etc_t:file r_file_perms;
allow syslogd_t resolv_conf_t:{ file lnk_file } r_file_perms;

# read localization information
allow syslogd_t locale_t:dir r_dir_perms;
allow syslogd_t locale_t:{file lnk_file} r_file_perms;

# Use capabilities.
allow syslogd_t syslogd_t:capability { net_bind_service dac_override };

# Inherit and use descriptors from init.
allow syslogd_t init_t:fd use;
allow syslogd_t { initrc_devpts_t console_device_t }:chr_file { read write };

# Modify/create log files.
create_append_log_file(syslogd_t, var_log_t)

# Create and bind to /dev/log or /var/run/log.
file_type_auto_trans(syslogd_t, { device_t var_run_t }, devlog_t, sock_file)
allow syslogd_t self:unix_dgram_socket create_socket_perms;
allow syslogd_t self:unix_dgram_socket { sendto };
allow syslogd_t self:unix_stream_socket create_socket_perms;
allow syslogd_t self:unix_stream_socket { listen accept };
allow syslogd_t devlog_t:unix_stream_socket name_bind;
allow syslogd_t devlog_t:unix_dgram_socket name_bind;

# Domains with the privlog attribute may log to syslogd.
allow privlog devlog_t:sock_file rw_file_perms;
can_unix_send(privlog,syslogd_t)
can_unix_connect(privlog,syslogd_t)
# allow /dev/log to be a link elsewhere for chroot setup
allow privlog devlog_t:lnk_file read;

# Write to the cron log.
allow syslogd_t cron_log_t:file rw_file_perms;

# Added by Us
allow syslogd_t any_socket_t:udp_socket { sendto };
allow syslogd_t netif_eth0_t:netif { udp_send };
allow syslogd_t netif_lo_t:netif { udp_recv udp_send };
allow syslogd_t netmsg_eth0_t:udp_socket { recvfrom };
allow syslogd_t node_lo_t:node { udp_recv udp_send };
allow syslogd_t node_t:node { udp_send };
allow syslogd_t port_t:udp_socket { name_bind };
allow syslogd_t syslogd_t:udp_socket { bind connect create read setopt write };
allow syslogd_t var_spool_t:file { execute getattr read };
allow syslogd_t var_yp_t:dir { search };


#DESC Tmpreaper - Monitor and maintain temporary files
#
# Author:  Russell Coker <russell@coker.com.au>
#

#################################
#
# Rules for the tmpreaper_t domain.
#
type tmpreaper_t, domain, privlog;
type tmpreaper_exec_t, file_type, sysadmfile, exec_type;

role system_r types tmpreaper_t;

domain_auto_trans(system_crond_t, tmpreaper_exec_t, tmpreaper_t)
uses_shlib(tmpreaper_t)
allow tmpreaper_t crond_t:fd use;
allow tmpreaper_t crond_t:fifo_file { read write };
allow tmpreaper_t tmpfile:dir { rw_dir_perms rmdir };
allow tmpreaper_t tmpfile:notdevfile_class_set { getattr unlink };
allow tmpreaper_t home_type:notdevfile_class_set { getattr unlink };
allow tmpreaper_t self:process { fork sigchld };
allow tmpreaper_t self:capability { dac_override dac_read_search fowner };
allow tmpreaper_t fs_t:filesystem getattr;

r_dir_file(tmpreaper_t, etc_t)
allow tmpreaper_t var_t:dir { getattr search };
r_dir_file(tmpreaper_t, var_lib_t)
allow tmpreaper_t device_t:dir { getattr search };

ifdef(`rpm.te', `
# for the Red Hat tmpreaper program which also manages tetex indexes
create_dir_file(tmpreaper_t, tetex_data_t)
')
#DESC Useradd - Manage system user accounts
#
# Authors:  Chris Vance <cvance@tislabs.com>
#

#################################
#
# Rules for the useradd_t domain.
#
# useradd_t is the domain of the useradd/userdel programs when
# executed through the suseradd/suserdel wrapper.
#
type useradd_t, domain, privlog, auth, privowner;
role sysadm_r types useradd_t;

general_domain_access(useradd_t);

uses_shlib(useradd_t);

type useradd_exec_t, file_type, sysadmfile, exec_type;
domain_auto_trans(sysadm_t, useradd_exec_t, useradd_t)

# Add/remove user home directories
file_type_auto_trans(useradd_t, home_root_t, user_home_dir_t)
file_type_auto_trans(useradd_t, user_home_dir_t, user_home_t)

# create mail spool file in /var/mail
allow useradd_t mail_spool_t:dir {search write add_name remove_name};
allow useradd_t mail_spool_t:file {create setattr getattr unlink};
# /var/mail is a link to /var/spool/mail
allow useradd_t mail_spool_t:lnk_file {read};

# Use capabilities.
allow useradd_t useradd_t:capability { fowner chown dac_override fsetid setuid sys_resource };

# Allow access to context for shadow file
allow useradd_t security_t:security { context_to_sid };

# Inherit and use descriptors from login.
allow useradd_t privfd:fd use;

# Execute /usr/bin/{passwd,chfn,chsh} and /usr/sbin/{useradd,vipw}.
allow useradd_t { bin_t sbin_t }:dir r_dir_perms;
can_exec(useradd_t, { bin_t sbin_t shell_exec_t })

# allow checking if a shell is executable
allow useradd_t shell_exec_t:file execute;

# Update /etc/shadow and /etc/passwd
file_type_auto_trans(useradd_t, etc_t, shadow_t)
allow useradd_t etc_t:file create_file_perms;

allow useradd_t { etc_t shadow_t }:file { relabelfrom relabelto };

# allow vipw to create temporary files under /var/tmp/vi.recover
tmp_domain(useradd)

# /usr/bin/userdel locks the user being deleted, allow write access to utmp
allow useradd_t initrc_var_run_t:file { write };

# useradd/userdel request read/write for /var/log/lastlog, and read of /dev, 
# but will operate without them.
dontaudit useradd_t { device_t var_t }:dir { search };

# Access terminals.
allow useradd_t ttyfile:chr_file rw_file_perms;
allow useradd_t ptyfile:chr_file rw_file_perms;
ifdef(`gnome-pty-helper.te', `allow useradd_t gphdomain:fd use;')
#DESC Xauth - X authority file utility
#
# Domains for the xauth program.

# Author: Russell Coker <russell@coker.com.au>
#
# xauth_exec_t is the type of the xauth executable.
#
type xauth_exec_t, file_type, sysadmfile, exec_type;

# Everything else is in the xauth_domain macro in
# macros/program/xauth_macros.te.
##############################
#
# Assertions for the type enforcement (TE) configuration.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

##################################
#
# Access vector assertions.
#
# An access vector assertion specifies permissions that should not be in
# an access vector based on a source type, a target type, and a class.
# If any of the specified permissions are in the corresponding access
# vector, then the policy compiler will reject the policy configuration.
# Currently, there is only one kind of access vector assertion, neverallow, 
# but support for the other kinds of vectors could be easily added.  Access 
# vector assertions use the same syntax as access vector rules.
#

#
# Verify that every type that can be entered by
# a domain is also tagged as a domain.
#
neverallow domain ~domain:process transition;

#
# Verify that only the insmod_t, ifconfig_t, and kernel_t domains 
# have the sys_module capability.
#
neverallow ~{ insmod_t ifconfig_t kernel_t } self:capability sys_module;

#
# Verify that executable types, the system dynamic loaders, and the
# system shared libraries can only be modified by administrators.
#
neverallow ~{ldconfig_t admin} { exec_type ld_so_t shlib_t }:file { write append unlink rename };

#
# Verify that other system software can only be modified by administrators.
#
neverallow ~{ldconfig_t admin} { lib_t bin_t sbin_t }:dir { add_name remove_name rename };
neverallow ~admin { lib_t bin_t sbin_t }:file { write append unlink rename };

#
# Verify that only certain domains have access to the raw disk devices.
#
neverallow ~{ ifdef(`bootloader.te', `bootloader_t') fsadm_t mount_t } fixed_disk_device_t:devfile_class_set { read write append };

#
# Verify that only the X server and klogd have access to memory devices.
#
neverallow ~privmem memory_device_t:devfile_class_set { read write append };

#
# Verify that /proc/kmsg is only accessible to klogd.
#
neverallow ~klogd_t proc_kmsg_t:file ~stat_file_perms;

#
# Verify that /proc/kcore is inaccessible.
#
neverallow * proc_kcore_t:file ~stat_file_perms;

#
# Verify that sysctl variables are only changeable
# by initrc and administrators.
#
neverallow ~{ initrc_t admin kernel_t insmod_t } sysctl_t:file { write append };
neverallow ~{ initrc_t admin } sysctl_fs_t:file { write append };
neverallow ~{ init_t initrc_t admin kernel_t insmod_t } sysctl_kernel_t:file { write append };
neverallow ~{ initrc_t admin } sysctl_net_t:file { write append };
neverallow ~{ initrc_t admin } sysctl_net_unix_t:file { write append };
neverallow ~{ initrc_t admin } sysctl_vm_t:file { write append };
neverallow ~{ initrc_t admin } sysctl_dev_t:file { write append };
neverallow ~{ initrc_t admin } sysctl_modprobe_t:file { write append };

#
# Verify that certain domains are limited to only being
# entered by their entrypoint types and to only executing
# the dynamic loader without a transition to another domain.
#

define(`assert_execute', `
    ifelse($#, 0, , 
           $#, 1, 
           ``neverallow $1_t ~$1_exec_t:file entrypoint; neverallow $1_t ~{ $1_exec_t ld_so_t }:file execute_no_trans;'',
           `assert_execute($1) assert_execute(shift($@))')')

ifdef(`getty.te', `assert_execute(getty)')
assert_execute(klogd)
ifdef(`atd.te', `assert_execute(atd)')
ifdef(`tcpd.te', `assert_execute(tcpd)')
ifdef(`portmap.te', `assert_execute(portmap)')
ifdef(`syslogd.te', `assert_execute(syslogd)')
ifdef(`rpcd.te', `assert_execute(rpcd)')
ifdef(`rlogind.te', `assert_execute(rlogind)')
ifdef(`ypbind.te', `assert_execute(ypbind)')
ifdef(`xfs.te', `assert_execute(xfs)')
ifdef(`gpm.te', `assert_execute(gpm)')

ifdef(`login.te', `
neverallow { local_login_t remote_login_t } ~login_exec_t:file entrypoint;
neverallow { local_login_t remote_login_t } ~ld_so_t:file execute_no_trans;
')

#
# Verify that the passwd domain can only be entered by its
# entrypoint type and can only execute the dynamic loader
# and the ordinary passwd program without a transition to another domain.
#
ifdef(`passwd.te',
`neverallow passwd_t ~{ admin_passwd_exec_t passwd_exec_t }:file entrypoint;
neverallow passwd_t ~{ bin_t sbin_t shell_exec_t ld_so_t passwd_real_exec_t }:file execute_no_trans;')

#
# Verify that only the admin domains and initrc_t have avc_toggle.
#
neverallow ~{ admin initrc_t } kernel_t:system avc_toggle;
